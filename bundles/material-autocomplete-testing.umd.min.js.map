{"version":3,"sources":["src/material/material-autocomplete-testing.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","material","autocomplete","testing","tslib","cdk","coercion","this","tslib_1","MatAutocompleteOptionHarness","_super","apply","arguments","__extends","with","options","_this","HarnessPredicate","addOption","text","harness","title","__awaiter","_a","_b","__generator","_c","label","stringMatches","getText","sent","prototype","click","host","hostSelector","ComponentHarness","MatAutocompleteOptionGroupHarness","_label","locatorFor","labelText","getLabelText","PANEL_SELECTOR","MatAutocompleteHarness","_documentRootLocator","documentRootLocatorFactory","_panel","_optionalPanel","locatorForOptional","_options","locatorForAll","_groups","getAttribute","attributeName","isDisabled","disabled","coerceBooleanProperty","getProperty","focus","blur","enterText","value","sendKeys","getPanel","getOptions","getOptionGroups","isPanelVisible","hasClass","isOpen","Object","defineProperty"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('@angular/cdk/testing'), require('@angular/cdk/coercion')) :\n    typeof define === 'function' && define.amd ? define('@angular/material/autocomplete/testing', ['exports', 'tslib', '@angular/cdk/testing', '@angular/cdk/coercion'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.autocomplete = global.ng.material.autocomplete || {}, global.ng.material.autocomplete.testing = {}), global.tslib, global.ng.cdk.testing, global.ng.cdk.coercion));\n}(this, function (exports, tslib_1, testing, coercion) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Harness for interacting with a the `mat-option` for a `mat-autocomplete` in tests.\n     * @dynamic\n     */\n    var MatAutocompleteOptionHarness = /** @class */ (function (_super) {\n        tslib_1.__extends(MatAutocompleteOptionHarness, _super);\n        function MatAutocompleteOptionHarness() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        MatAutocompleteOptionHarness.with = function (options) {\n            var _this = this;\n            if (options === void 0) { options = {}; }\n            return new testing.HarnessPredicate(MatAutocompleteOptionHarness, options)\n                .addOption('text', options.text, function (harness, title) { return tslib_1.__awaiter(_this, void 0, void 0, function () { var _a, _b; return tslib_1.__generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        _b = (_a = testing.HarnessPredicate).stringMatches;\n                        return [4 /*yield*/, harness.getText()];\n                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent(), title])];\n                }\n            }); }); });\n        };\n        /** Clicks the option. */\n        MatAutocompleteOptionHarness.prototype.click = function () {\n            return tslib_1.__awaiter(this, void 0, void 0, function () {\n                return tslib_1.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.host()];\n                        case 1: return [2 /*return*/, (_a.sent()).click()];\n                    }\n                });\n            });\n        };\n        /** Gets a promise for the option's label text. */\n        MatAutocompleteOptionHarness.prototype.getText = function () {\n            return tslib_1.__awaiter(this, void 0, void 0, function () {\n                return tslib_1.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.host()];\n                        case 1: return [2 /*return*/, (_a.sent()).text()];\n                    }\n                });\n            });\n        };\n        MatAutocompleteOptionHarness.hostSelector = '.mat-autocomplete-panel .mat-option';\n        return MatAutocompleteOptionHarness;\n    }(testing.ComponentHarness));\n    /**\n     * Harness for interacting with a the `mat-optgroup` for a `mat-autocomplete` in tests.\n     * @dynamic\n     */\n    var MatAutocompleteOptionGroupHarness = /** @class */ (function (_super) {\n        tslib_1.__extends(MatAutocompleteOptionGroupHarness, _super);\n        function MatAutocompleteOptionGroupHarness() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this._label = _this.locatorFor('.mat-optgroup-label');\n            return _this;\n        }\n        MatAutocompleteOptionGroupHarness.with = function (options) {\n            var _this = this;\n            if (options === void 0) { options = {}; }\n            return new testing.HarnessPredicate(MatAutocompleteOptionGroupHarness, options)\n                .addOption('labelText', options.labelText, function (harness, title) { return tslib_1.__awaiter(_this, void 0, void 0, function () { var _a, _b; return tslib_1.__generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        _b = (_a = testing.HarnessPredicate).stringMatches;\n                        return [4 /*yield*/, harness.getLabelText()];\n                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent(), title])];\n                }\n            }); }); });\n        };\n        /** Gets a promise for the option group's label text. */\n        MatAutocompleteOptionGroupHarness.prototype.getLabelText = function () {\n            return tslib_1.__awaiter(this, void 0, void 0, function () {\n                return tslib_1.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this._label()];\n                        case 1: return [2 /*return*/, (_a.sent()).text()];\n                    }\n                });\n            });\n        };\n        MatAutocompleteOptionGroupHarness.hostSelector = '.mat-autocomplete-panel .mat-optgroup';\n        return MatAutocompleteOptionGroupHarness;\n    }(testing.ComponentHarness));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Selector for the autocomplete panel. */\n    var PANEL_SELECTOR = '.mat-autocomplete-panel';\n    /**\n     * Harness for interacting with a standard mat-autocomplete in tests.\n     * @dynamic\n     */\n    var MatAutocompleteHarness = /** @class */ (function (_super) {\n        tslib_1.__extends(MatAutocompleteHarness, _super);\n        function MatAutocompleteHarness() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this._documentRootLocator = _this.documentRootLocatorFactory();\n            _this._panel = _this._documentRootLocator.locatorFor(PANEL_SELECTOR);\n            _this._optionalPanel = _this._documentRootLocator.locatorForOptional(PANEL_SELECTOR);\n            _this._options = _this._documentRootLocator.locatorForAll(MatAutocompleteOptionHarness);\n            _this._groups = _this._documentRootLocator.locatorForAll(MatAutocompleteOptionGroupHarness);\n            return _this;\n        }\n        /**\n         * Gets a `HarnessPredicate` that can be used to search for an autocomplete with\n         * specific attributes.\n         * @param options Options for narrowing the search:\n         *   - `name` finds an autocomplete with a specific name.\n         * @return a `HarnessPredicate` configured with the given options.\n         */\n        MatAutocompleteHarness.with = function (options) {\n            if (options === void 0) { options = {}; }\n            return new testing.HarnessPredicate(MatAutocompleteHarness, options);\n        };\n        MatAutocompleteHarness.prototype.getAttribute = function (attributeName) {\n            return tslib_1.__awaiter(this, void 0, void 0, function () {\n                return tslib_1.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.host()];\n                        case 1: return [2 /*return*/, (_a.sent()).getAttribute(attributeName)];\n                    }\n                });\n            });\n        };\n        /** Gets a boolean promise indicating if the autocomplete input is disabled. */\n        MatAutocompleteHarness.prototype.isDisabled = function () {\n            return tslib_1.__awaiter(this, void 0, void 0, function () {\n                var disabled, _a;\n                return tslib_1.__generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0: return [4 /*yield*/, this.host()];\n                        case 1:\n                            disabled = (_b.sent()).getAttribute('disabled');\n                            _a = coercion.coerceBooleanProperty;\n                            return [4 /*yield*/, disabled];\n                        case 2: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];\n                    }\n                });\n            });\n        };\n        /** Gets a promise for the autocomplete's text. */\n        MatAutocompleteHarness.prototype.getText = function () {\n            return tslib_1.__awaiter(this, void 0, void 0, function () {\n                return tslib_1.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.host()];\n                        case 1: return [2 /*return*/, (_a.sent()).getProperty('value')];\n                    }\n                });\n            });\n        };\n        /** Focuses the input and returns a void promise that indicates when the action is complete. */\n        MatAutocompleteHarness.prototype.focus = function () {\n            return tslib_1.__awaiter(this, void 0, void 0, function () {\n                return tslib_1.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.host()];\n                        case 1: return [2 /*return*/, (_a.sent()).focus()];\n                    }\n                });\n            });\n        };\n        /** Blurs the input and returns a void promise that indicates when the action is complete. */\n        MatAutocompleteHarness.prototype.blur = function () {\n            return tslib_1.__awaiter(this, void 0, void 0, function () {\n                return tslib_1.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.host()];\n                        case 1: return [2 /*return*/, (_a.sent()).blur()];\n                    }\n                });\n            });\n        };\n        /** Enters text into the autocomplete. */\n        MatAutocompleteHarness.prototype.enterText = function (value) {\n            return tslib_1.__awaiter(this, void 0, void 0, function () {\n                return tslib_1.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.host()];\n                        case 1: return [2 /*return*/, (_a.sent()).sendKeys(value)];\n                    }\n                });\n            });\n        };\n        /** Gets the autocomplete panel. */\n        MatAutocompleteHarness.prototype.getPanel = function () {\n            return tslib_1.__awaiter(this, void 0, void 0, function () {\n                return tslib_1.__generator(this, function (_a) {\n                    return [2 /*return*/, this._panel()];\n                });\n            });\n        };\n        /** Gets the options inside the autocomplete panel. */\n        MatAutocompleteHarness.prototype.getOptions = function () {\n            return tslib_1.__awaiter(this, void 0, void 0, function () {\n                return tslib_1.__generator(this, function (_a) {\n                    return [2 /*return*/, this._options()];\n                });\n            });\n        };\n        /** Gets the groups of options inside the panel. */\n        MatAutocompleteHarness.prototype.getOptionGroups = function () {\n            return tslib_1.__awaiter(this, void 0, void 0, function () {\n                return tslib_1.__generator(this, function (_a) {\n                    return [2 /*return*/, this._groups()];\n                });\n            });\n        };\n        /** Gets whether the autocomplete panel is visible. */\n        MatAutocompleteHarness.prototype.isPanelVisible = function () {\n            return tslib_1.__awaiter(this, void 0, void 0, function () {\n                return tslib_1.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this._panel()];\n                        case 1: return [2 /*return*/, (_a.sent()).hasClass('mat-autocomplete-visible')];\n                    }\n                });\n            });\n        };\n        /** Gets whether the autocomplete is open. */\n        MatAutocompleteHarness.prototype.isOpen = function () {\n            return tslib_1.__awaiter(this, void 0, void 0, function () {\n                return tslib_1.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this._optionalPanel()];\n                        case 1: return [2 /*return*/, !!(_a.sent())];\n                    }\n                });\n            });\n        };\n        MatAutocompleteHarness.hostSelector = '.mat-autocomplete-trigger';\n        return MatAutocompleteHarness;\n    }(testing.ComponentHarness));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    exports.MatAutocompleteHarness = MatAutocompleteHarness;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=material-autocomplete-testing.umd.js.map\n"]}