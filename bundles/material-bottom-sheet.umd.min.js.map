{"version":3,"sources":["src/material/material-bottom-sheet.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","material","bottomSheet","cdk","overlay","portal","common","core","tslib","layout","animations","a11y","bidi","rxjs","keycodes","operators","scrolling","coercion","platform","this","i1","i0","MAT_BOTTOM_SHEET_DATA","InjectionToken","MatBottomSheetConfig","data","hasBackdrop","disableClose","ariaLabel","closeOnNavigation","autoFocus","restoreFocus","matBottomSheetAnimations","bottomSheetState","trigger","state","style","transform","transition","animate","AnimationDurations","COMPLEX","AnimationCurves","ACCELERATION_CURVE","EXITING","DECELERATION_CURVE","MatBottomSheetContainer","_super","_elementRef","_changeDetectorRef","_focusTrapFactory","breakpointObserver","document","bottomSheetConfig","_this","call","_animationState","_animationStateChanged","EventEmitter","_elementFocusedBeforeOpened","attachDomPortal","_validatePortalAttached","_setPanelClass","_savePreviouslyFocusedElement","_portalOutlet","_document","_breakpointSubscription","observe","Breakpoints","Medium","Large","XLarge","subscribe","_toggleClass","isMatched","__extends","prototype","attachComponentPortal","attachTemplatePortal","enter","_destroyed","detectChanges","exit","markForCheck","ngOnDestroy","unsubscribe","_onAnimationDone","event","toState","_restoreFocus","_trapFocus","emit","_onAnimationStart","cssClass","add","classList","nativeElement","remove","hasAttached","Error","element","panelClass","Array","isArray","forEach","_focusTrap","create","focusInitialElementWhenReady","activeElement","contains","focus","toFocus","destroy","Promise","resolve","then","decorators","type","Component","args","selector","template","changeDetection","ChangeDetectionStrategy","OnPush","encapsulation","ViewEncapsulation","None","host","class","tabindex","role","aria-modal","[attr.aria-label]","[@state]","(@state.start)","(@state.done)","styles","ctorParameters","ElementRef","ChangeDetectorRef","FocusTrapFactory","BreakpointObserver","undefined","Optional","Inject","DOCUMENT","propDecorators","ViewChild","CdkPortalOutlet","static","BasePortalOutlet","MatBottomSheetModule","NgModule","imports","CommonModule","OverlayModule","MatCommonModule","PortalModule","declarations","entryComponents","MatBottomSheetRef","containerInstance","_overlayRef","_location","_afterDismissed","Subject","_afterOpened","pipe","filter","phaseName","take","next","complete","clearTimeout","_closeFallbackTimeout","dispose","detachments","_result","merge","backdropClick","keydownEvents","keyCode","ESCAPE","hasModifierKey","preventDefault","dismiss","result","closed","setTimeout","totalTime","detachBackdrop","afterDismissed","asObservable","afterOpened","OverlayKeyboardDispatcher","_attachedOverlays","_keydownListener","overlays","i","length","_keydownEventSubscriptions","_keydownEvents","_detach","overlayRef","_isAttached","body","addEventListener","push","index","indexOf","splice","removeEventListener","Injectable","providedIn","ɵprov","ɵɵdefineInjectable","OverlayKeyboardDispatcher_Factory","ɵɵinject","token","SkipSelf","BlockScrollStrategy","_viewportRuler","_previousHTMLStyles","top","left","_isEnabled","attach","enable","_canBeEnabled","root","documentElement","_previousScrollPosition","getViewportScrollPosition","coerceCssPixelValue","disable","html","htmlStyle","bodyStyle","previousHtmlScrollBehavior","scrollBehavior","previousBodyScrollBehavior","window","scroll","viewport","getViewportSize","scrollHeight","height","scrollWidth","width","getMatScrollStrategyAlreadyAttachedError","CloseScrollStrategy","_scrollDispatcher","_ngZone","_config","_scrollSubscription","run","detach","stream","scrolled","threshold","_initialScrollPosition","scrollPosition","Math","abs","updatePosition","NoopScrollStrategy","isElementScrolledOutsideView","scrollContainers","some","containerBounds","bottom","right","isElementClippedByScrolling","scrollContainerRect","hasV8BreakIterator","RepositionScrollStrategy","scrollThrottle","autoClose","overlayRect","overlayElement","getBoundingClientRect","_a","Intl","v8BreakIterator","Platform","_platformId","isBrowser","isPlatformBrowser","EDGE","test","navigator","userAgent","TRIDENT","BLINK","chrome","CSS","WEBKIT","IOS","FIREFOX","ANDROID","SAFARI","Object","PLATFORM_ID","Platform_Factory","ScrollDispatcher","_platform","_scrolled","_globalSubscription","_scrolledCount","Map","register","scrollable","has","set","elementScrolled","deregister","scrollableReference","get","delete","auditTimeInMs","Observable","observer","_addGlobalListener","subscription","auditTime","_removeGlobalListener","of","_","container","ancestorScrolled","elementRef","ancestors","getAncestorScrollContainers","target","scrollingContainers","_subscription","_scrollableContainsElement","scrollableElement","getElementRef","parentElement","runOutsideAngular","fromEvent","NgZone","ScrollDispatcher_Factory","ViewportRuler","ngZone","_change","_invalidateCache","change","_updateViewportSize","_viewportSize","output","getViewportRect","documentRect","scrollTop","scrollY","scrollLeft","scrollX","throttleTime","innerWidth","innerHeight","ViewportRuler_Factory","ScrollStrategyOptions","noop","close","config","block","reposition","ScrollStrategyOptions_Factory","OverlayConfig","e_1","scrollStrategy","backdropClass","disposeOnNavigation","configKeys","keys","configKeys_1","__values","configKeys_1_1","done","key","value","e_1_1","error","return","OverlayContainer","_containerElement","parentNode","removeChild","getContainerElement","_createContainer","previousContainers","getElementsByClassName","createElement","appendChild","OverlayContainer_Factory","OverlayRef","_host","_pane","_keyboardDispatcher","_backdropElement","_backdropClick","_attachments","_detachments","_locationChanges","Subscription","EMPTY","_backdropClickHandler","_keydownEventsObservable","_scrollStrategy","_positionStrategy","positionStrategy","defineProperty","enumerable","configurable","attachResult","_previousHostParent","_updateStackingOrder","_updateElementSize","_updateElementDirection","onStable","_togglePointerEvents","_attachBackdrop","_toggleClasses","detachmentResult","_detachContentWhenStable","isAttached","_disposeScrollStrategy","attachments","getConfig","apply","updatePositionStrategy","strategy","updateSize","sizeConfig","__assign","setDirection","dir","direction","addPanelClass","classes","removePanelClass","getDirection","updateScrollStrategy","setAttribute","minWidth","minHeight","maxWidth","maxHeight","enablePointer","pointerEvents","insertBefore","requestAnimationFrame","nextSibling","backdropToDetach","timeoutId","finishDetach","cssClasses","isAdd","coerceArray","takeUntil","children","ConnectionPositionPair","origin","offsetX","offsetY","originX","originY","overlayX","overlayY","ScrollingVisibility","ConnectedOverlayPositionChange","connectionPair","scrollableViewProperties","validateVerticalPosition","property","validateHorizontalPosition","FlexibleConnectedPositionStrategy","connectedTo","_overlayContainer","_lastBoundingBoxSize","_isPushed","_canPush","_growAfterOpen","_hasFlexibleDimensions","_positionLocked","_viewportMargin","_scrollables","_preferredPositions","_positionChanges","_resizeSubscription","_offsetX","_offsetY","_appliedPanelClasses","positionChanges","setOrigin","_validatePositions","hostElement","_boundingBox","_isDisposed","_isInitialRender","_lastPosition","e_2","_b","reapplyLastPosition","_clearPanelClasses","_resetOverlayElementStyles","_resetBoundingBoxStyles","_viewportRect","_getNarrowedViewportRect","_originRect","_getOriginRect","_overlayRect","fallback","originRect","viewportRect","flexibleFits","_c","_d","pos","originPoint","_getOriginPoint","overlayPoint","_getOverlayPoint","overlayFit","_getOverlayFit","isCompletelyWithinViewport","_applyPosition","_canFitWithFlexibleDimensions","position","boundingBoxRect","_calculateBoundingBoxRect","visibleArea","bestFit","bestScore","flexibleFits_1","flexibleFits_1_1","fit","score","weight","e_2_1","_previousPushAmount","extendStyles","alignItems","justifyContent","lastPosition","withScrollableContainers","scrollables","withPositions","positions","withViewportMargin","margin","withFlexibleDimensions","flexibleDimensions","withGrowAfterOpen","growAfterOpen","withPush","canPush","withLockedPosition","isLocked","_origin","withDefaultOffsetX","offset","withDefaultOffsetY","withTransformOriginOn","_transformOriginSelector","x","startX","_isRtl","endX","y","overlayStartX","point","_getOffset","topOverflow","bottomOverflow","visibleWidth","_subtractOverflows","visibleHeight","fitsInViewportVertically","fitsInViewportHorizontally","availableHeight","availableWidth","_pushOverlayOnScreen","start","pushX","pushY","overflowRight","max","overflowBottom","overflowTop","overflowLeft","_setTransformOrigin","_setOverlayElementStyles","_setBoundingBoxStyles","_addPanelClasses","observers","_getScrollVisibility","changeEvent","xOrigin","elements","querySelectorAll","yOrigin","transformOrigin","isRtl","smallestDistanceToViewportEdge","min","previousHeight","previousWidth","_hasExactPosition","hasExactPosition","hasFlexibleDimensions","_getExactOverlayY","_getExactOverlayX","transformString","trim","virtualKeyboardOffset","clientHeight","clientWidth","originBounds","overlayBounds","scrollContainerBounds","map","isOriginClipped","isOriginOutsideView","isOverlayClipped","isOverlayOutsideView","overflows","_i","arguments","reduce","currentValue","currentOverflow","axis","pair","HTMLElement","dest","source","hasOwnProperty","ConnectedPositionStrategy","originPos","overlayPos","viewportRuler","overlayContainer","withFallbackPosition","_direction","recalculateLastPosition","withDirection","withOffsetX","withOffsetY","slice","GlobalPositionStrategy","_cssPosition","_topOffset","_bottomOffset","_leftOffset","_rightOffset","_alignItems","_justifyContent","_width","_height","centerHorizontally","centerVertically","parentStyles","marginLeft","marginTop","marginBottom","marginRight","parent","OverlayPositionBuilder","flexibleConnectedTo","OverlayPositionBuilder_Factory","nextUniqueId","Overlay","scrollStrategies","_componentFactoryResolver","_positionBuilder","_injector","_directionality","_createHostElement","pane","_createPaneElement","portalOutlet","_createPortalOutlet","overlayConfig","id","_appRef","ApplicationRef","DomPortalOutlet","ComponentFactoryResolver","Injector","Directionality","Location","MAT_BOTTOM_SHEET_DEFAULT_OPTIONS","MatBottomSheet","_overlay","_parentBottomSheet","_defaultOptions","_bottomSheetRefAtThisLevel","_openedBottomSheetRef","open","componentOrTemplateRef","_applyConfigDefaults","defaults","_createOverlay","_attachContainer","ref","TemplateRef","TemplatePortal","$implicit","bottomSheetRef","portal$1","ComponentPortal","_createInjector","contentRef","instance","injector","PortalInjector","viewContainerRef","WeakMap","containerPortal","userInjector","injectionTokens","MatBottomSheet_Factory","INJECTOR"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/cdk/overlay'), require('@angular/cdk/portal'), require('@angular/common'), require('@angular/core'), require('@angular/material/core'), require('tslib'), require('@angular/cdk/layout'), require('@angular/animations'), require('@angular/cdk/a11y'), require('@angular/cdk/bidi'), require('rxjs'), require('@angular/cdk/keycodes'), require('rxjs/operators'), require('@angular/cdk/scrolling'), require('@angular/cdk/coercion'), require('@angular/cdk/platform')) :\n    typeof define === 'function' && define.amd ? define('@angular/material/bottom-sheet', ['exports', '@angular/cdk/overlay', '@angular/cdk/portal', '@angular/common', '@angular/core', '@angular/material/core', 'tslib', '@angular/cdk/layout', '@angular/animations', '@angular/cdk/a11y', '@angular/cdk/bidi', 'rxjs', '@angular/cdk/keycodes', 'rxjs/operators', '@angular/cdk/scrolling', '@angular/cdk/coercion', '@angular/cdk/platform'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.bottomSheet = {}), global.ng.cdk.overlay, global.ng.cdk.portal, global.ng.common, global.ng.core, global.ng.material.core, global.tslib, global.ng.cdk.layout, global.ng.animations, global.ng.cdk.a11y, global.ng.cdk.bidi, global.rxjs, global.ng.cdk.keycodes, global.rxjs.operators, global.ng.cdk.scrolling, global.ng.cdk.coercion, global.ng.cdk.platform));\n}(this, (function (exports, overlay, portal, i1, i0, core, tslib, layout, animations, a11y, bidi, rxjs, keycodes, operators, scrolling, coercion, platform) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Injection token that can be used to access the data that was passed in to a bottom sheet. */\n    var MAT_BOTTOM_SHEET_DATA = new i0.InjectionToken('MatBottomSheetData');\n    /**\n     * Configuration used when opening a bottom sheet.\n     */\n    var MatBottomSheetConfig = /** @class */ (function () {\n        function MatBottomSheetConfig() {\n            /** Data being injected into the child component. */\n            this.data = null;\n            /** Whether the bottom sheet has a backdrop. */\n            this.hasBackdrop = true;\n            /** Whether the user can use escape or clicking outside to close the bottom sheet. */\n            this.disableClose = false;\n            /** Aria label to assign to the bottom sheet element. */\n            this.ariaLabel = null;\n            /**\n             * Whether the bottom sheet should close when the user goes backwards/forwards in history.\n             * Note that this usually doesn't include clicking on links (unless the user is using\n             * the `HashLocationStrategy`).\n             */\n            this.closeOnNavigation = true;\n            // Note that this is disabled by default, because while the a11y recommendations are to focus\n            // the first focusable element, doing so prevents screen readers from reading out the\n            // rest of the bottom sheet content.\n            /** Whether the bottom sheet should focus the first focusable element on open. */\n            this.autoFocus = false;\n            /**\n             * Whether the bottom sheet should restore focus to the\n             * previously-focused element, after it's closed.\n             */\n            this.restoreFocus = true;\n        }\n        return MatBottomSheetConfig;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Animations used by the Material bottom sheet. */\n    var matBottomSheetAnimations = {\n        /** Animation that shows and hides a bottom sheet. */\n        bottomSheetState: animations.trigger('state', [\n            animations.state('void, hidden', animations.style({ transform: 'translateY(100%)' })),\n            animations.state('visible', animations.style({ transform: 'translateY(0%)' })),\n            animations.transition('visible => void, visible => hidden', animations.animate(core.AnimationDurations.COMPLEX + \" \" + core.AnimationCurves.ACCELERATION_CURVE)),\n            animations.transition('void => visible', animations.animate(core.AnimationDurations.EXITING + \" \" + core.AnimationCurves.DECELERATION_CURVE)),\n        ])\n    };\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // TODO(crisbeto): consolidate some logic between this, MatDialog and MatSnackBar\n    /**\n     * Internal component that wraps user-provided bottom sheet content.\n     * @docs-private\n     */\n    var MatBottomSheetContainer = /** @class */ (function (_super) {\n        tslib.__extends(MatBottomSheetContainer, _super);\n        function MatBottomSheetContainer(_elementRef, _changeDetectorRef, _focusTrapFactory, breakpointObserver, document, \n        /** The bottom sheet configuration. */\n        bottomSheetConfig) {\n            var _this = _super.call(this) || this;\n            _this._elementRef = _elementRef;\n            _this._changeDetectorRef = _changeDetectorRef;\n            _this._focusTrapFactory = _focusTrapFactory;\n            _this.bottomSheetConfig = bottomSheetConfig;\n            /** The state of the bottom sheet animations. */\n            _this._animationState = 'void';\n            /** Emits whenever the state of the animation changes. */\n            _this._animationStateChanged = new i0.EventEmitter();\n            /** Element that was focused before the bottom sheet was opened. */\n            _this._elementFocusedBeforeOpened = null;\n            /**\n             * Attaches a DOM portal to the bottom sheet container.\n             * @deprecated To be turned into a method.\n             * @breaking-change 10.0.0\n             */\n            _this.attachDomPortal = function (portal) {\n                _this._validatePortalAttached();\n                _this._setPanelClass();\n                _this._savePreviouslyFocusedElement();\n                return _this._portalOutlet.attachDomPortal(portal);\n            };\n            _this._document = document;\n            _this._breakpointSubscription = breakpointObserver\n                .observe([layout.Breakpoints.Medium, layout.Breakpoints.Large, layout.Breakpoints.XLarge])\n                .subscribe(function () {\n                _this._toggleClass('mat-bottom-sheet-container-medium', breakpointObserver.isMatched(layout.Breakpoints.Medium));\n                _this._toggleClass('mat-bottom-sheet-container-large', breakpointObserver.isMatched(layout.Breakpoints.Large));\n                _this._toggleClass('mat-bottom-sheet-container-xlarge', breakpointObserver.isMatched(layout.Breakpoints.XLarge));\n            });\n            return _this;\n        }\n        /** Attach a component portal as content to this bottom sheet container. */\n        MatBottomSheetContainer.prototype.attachComponentPortal = function (portal) {\n            this._validatePortalAttached();\n            this._setPanelClass();\n            this._savePreviouslyFocusedElement();\n            return this._portalOutlet.attachComponentPortal(portal);\n        };\n        /** Attach a template portal as content to this bottom sheet container. */\n        MatBottomSheetContainer.prototype.attachTemplatePortal = function (portal) {\n            this._validatePortalAttached();\n            this._setPanelClass();\n            this._savePreviouslyFocusedElement();\n            return this._portalOutlet.attachTemplatePortal(portal);\n        };\n        /** Begin animation of bottom sheet entrance into view. */\n        MatBottomSheetContainer.prototype.enter = function () {\n            if (!this._destroyed) {\n                this._animationState = 'visible';\n                this._changeDetectorRef.detectChanges();\n            }\n        };\n        /** Begin animation of the bottom sheet exiting from view. */\n        MatBottomSheetContainer.prototype.exit = function () {\n            if (!this._destroyed) {\n                this._animationState = 'hidden';\n                this._changeDetectorRef.markForCheck();\n            }\n        };\n        MatBottomSheetContainer.prototype.ngOnDestroy = function () {\n            this._breakpointSubscription.unsubscribe();\n            this._destroyed = true;\n        };\n        MatBottomSheetContainer.prototype._onAnimationDone = function (event) {\n            if (event.toState === 'hidden') {\n                this._restoreFocus();\n            }\n            else if (event.toState === 'visible') {\n                this._trapFocus();\n            }\n            this._animationStateChanged.emit(event);\n        };\n        MatBottomSheetContainer.prototype._onAnimationStart = function (event) {\n            this._animationStateChanged.emit(event);\n        };\n        MatBottomSheetContainer.prototype._toggleClass = function (cssClass, add) {\n            var classList = this._elementRef.nativeElement.classList;\n            add ? classList.add(cssClass) : classList.remove(cssClass);\n        };\n        MatBottomSheetContainer.prototype._validatePortalAttached = function () {\n            if (this._portalOutlet.hasAttached()) {\n                throw Error('Attempting to attach bottom sheet content after content is already attached');\n            }\n        };\n        MatBottomSheetContainer.prototype._setPanelClass = function () {\n            var element = this._elementRef.nativeElement;\n            var panelClass = this.bottomSheetConfig.panelClass;\n            if (Array.isArray(panelClass)) {\n                // Note that we can't use a spread here, because IE doesn't support multiple arguments.\n                panelClass.forEach(function (cssClass) { return element.classList.add(cssClass); });\n            }\n            else if (panelClass) {\n                element.classList.add(panelClass);\n            }\n        };\n        /** Moves the focus inside the focus trap. */\n        MatBottomSheetContainer.prototype._trapFocus = function () {\n            var element = this._elementRef.nativeElement;\n            if (!this._focusTrap) {\n                this._focusTrap = this._focusTrapFactory.create(element);\n            }\n            if (this.bottomSheetConfig.autoFocus) {\n                this._focusTrap.focusInitialElementWhenReady();\n            }\n            else {\n                var activeElement = this._document.activeElement;\n                // Otherwise ensure that focus is on the container. It's possible that a different\n                // component tried to move focus while the open animation was running. See:\n                // https://github.com/angular/components/issues/16215. Note that we only want to do this\n                // if the focus isn't inside the bottom sheet already, because it's possible that the\n                // consumer turned off `autoFocus` in order to move focus themselves.\n                if (activeElement !== element && !element.contains(activeElement)) {\n                    element.focus();\n                }\n            }\n        };\n        /** Restores focus to the element that was focused before the bottom sheet was opened. */\n        MatBottomSheetContainer.prototype._restoreFocus = function () {\n            var toFocus = this._elementFocusedBeforeOpened;\n            // We need the extra check, because IE can set the `activeElement` to null in some cases.\n            if (this.bottomSheetConfig.restoreFocus && toFocus && typeof toFocus.focus === 'function') {\n                toFocus.focus();\n            }\n            if (this._focusTrap) {\n                this._focusTrap.destroy();\n            }\n        };\n        /** Saves a reference to the element that was focused before the bottom sheet was opened. */\n        MatBottomSheetContainer.prototype._savePreviouslyFocusedElement = function () {\n            var _this = this;\n            this._elementFocusedBeforeOpened = this._document.activeElement;\n            // The `focus` method isn't available during server-side rendering.\n            if (this._elementRef.nativeElement.focus) {\n                Promise.resolve().then(function () { return _this._elementRef.nativeElement.focus(); });\n            }\n        };\n        MatBottomSheetContainer.decorators = [\n            { type: i0.Component, args: [{\n                        selector: 'mat-bottom-sheet-container',\n                        template: \"<ng-template cdkPortalOutlet></ng-template>\\r\\n\",\n                        changeDetection: i0.ChangeDetectionStrategy.OnPush,\n                        encapsulation: i0.ViewEncapsulation.None,\n                        animations: [matBottomSheetAnimations.bottomSheetState],\n                        host: {\n                            'class': 'mat-bottom-sheet-container',\n                            'tabindex': '-1',\n                            'role': 'dialog',\n                            'aria-modal': 'true',\n                            '[attr.aria-label]': 'bottomSheetConfig?.ariaLabel',\n                            '[@state]': '_animationState',\n                            '(@state.start)': '_onAnimationStart($event)',\n                            '(@state.done)': '_onAnimationDone($event)'\n                        },\n                        styles: [\".mat-bottom-sheet-container{padding:8px 16px;min-width:100vw;box-sizing:border-box;display:block;outline:0;max-height:80vh;overflow:auto}.cdk-high-contrast-active .mat-bottom-sheet-container{outline:1px solid}.mat-bottom-sheet-container-xlarge,.mat-bottom-sheet-container-large,.mat-bottom-sheet-container-medium{border-top-left-radius:4px;border-top-right-radius:4px}.mat-bottom-sheet-container-medium{min-width:384px;max-width:calc(100vw - 128px)}.mat-bottom-sheet-container-large{min-width:512px;max-width:calc(100vw - 256px)}.mat-bottom-sheet-container-xlarge{min-width:576px;max-width:calc(100vw - 384px)}\\n\"]\n                    }] }\n        ];\n        /** @nocollapse */\n        MatBottomSheetContainer.ctorParameters = function () { return [\n            { type: i0.ElementRef },\n            { type: i0.ChangeDetectorRef },\n            { type: a11y.FocusTrapFactory },\n            { type: layout.BreakpointObserver },\n            { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [i1.DOCUMENT,] }] },\n            { type: MatBottomSheetConfig }\n        ]; };\n        MatBottomSheetContainer.propDecorators = {\n            _portalOutlet: [{ type: i0.ViewChild, args: [portal.CdkPortalOutlet, { static: true },] }]\n        };\n        return MatBottomSheetContainer;\n    }(portal.BasePortalOutlet));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var MatBottomSheetModule = /** @class */ (function () {\n        function MatBottomSheetModule() {\n        }\n        MatBottomSheetModule.decorators = [\n            { type: i0.NgModule, args: [{\n                        imports: [\n                            i1.CommonModule,\n                            overlay.OverlayModule,\n                            core.MatCommonModule,\n                            portal.PortalModule,\n                        ],\n                        exports: [MatBottomSheetContainer, core.MatCommonModule],\n                        declarations: [MatBottomSheetContainer],\n                        entryComponents: [MatBottomSheetContainer],\n                    },] }\n        ];\n        return MatBottomSheetModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Reference to a bottom sheet dispatched from the bottom sheet service.\n     */\n    var MatBottomSheetRef = /** @class */ (function () {\n        function MatBottomSheetRef(containerInstance, _overlayRef, \n        // @breaking-change 8.0.0 `_location` parameter to be removed.\n        _location) {\n            var _this = this;\n            this._overlayRef = _overlayRef;\n            /** Subject for notifying the user that the bottom sheet has been dismissed. */\n            this._afterDismissed = new rxjs.Subject();\n            /** Subject for notifying the user that the bottom sheet has opened and appeared. */\n            this._afterOpened = new rxjs.Subject();\n            this.containerInstance = containerInstance;\n            this.disableClose = containerInstance.bottomSheetConfig.disableClose;\n            // Emit when opening animation completes\n            containerInstance._animationStateChanged.pipe(operators.filter(function (event) { return event.phaseName === 'done' && event.toState === 'visible'; }), operators.take(1))\n                .subscribe(function () {\n                _this._afterOpened.next();\n                _this._afterOpened.complete();\n            });\n            // Dispose overlay when closing animation is complete\n            containerInstance._animationStateChanged\n                .pipe(operators.filter(function (event) { return event.phaseName === 'done' && event.toState === 'hidden'; }), operators.take(1))\n                .subscribe(function () {\n                clearTimeout(_this._closeFallbackTimeout);\n                _overlayRef.dispose();\n            });\n            _overlayRef.detachments().pipe(operators.take(1)).subscribe(function () {\n                _this._afterDismissed.next(_this._result);\n                _this._afterDismissed.complete();\n            });\n            rxjs.merge(_overlayRef.backdropClick(), _overlayRef.keydownEvents().pipe(operators.filter(function (event) { return event.keyCode === keycodes.ESCAPE; }))).subscribe(function (event) {\n                if (!_this.disableClose &&\n                    (event.type !== 'keydown' || !keycodes.hasModifierKey(event))) {\n                    event.preventDefault();\n                    _this.dismiss();\n                }\n            });\n        }\n        /**\n         * Dismisses the bottom sheet.\n         * @param result Data to be passed back to the bottom sheet opener.\n         */\n        MatBottomSheetRef.prototype.dismiss = function (result) {\n            var _this = this;\n            if (!this._afterDismissed.closed) {\n                // Transition the backdrop in parallel to the bottom sheet.\n                this.containerInstance._animationStateChanged.pipe(operators.filter(function (event) { return event.phaseName === 'start'; }), operators.take(1)).subscribe(function (event) {\n                    // The logic that disposes of the overlay depends on the exit animation completing, however\n                    // it isn't guaranteed if the parent view is destroyed while it's running. Add a fallback\n                    // timeout which will clean everything up if the animation hasn't fired within the specified\n                    // amount of time plus 100ms. We don't need to run this outside the NgZone, because for the\n                    // vast majority of cases the timeout will have been cleared before it has fired.\n                    _this._closeFallbackTimeout = setTimeout(function () {\n                        _this._overlayRef.dispose();\n                    }, event.totalTime + 100);\n                    _this._overlayRef.detachBackdrop();\n                });\n                this._result = result;\n                this.containerInstance.exit();\n            }\n        };\n        /** Gets an observable that is notified when the bottom sheet is finished closing. */\n        MatBottomSheetRef.prototype.afterDismissed = function () {\n            return this._afterDismissed.asObservable();\n        };\n        /** Gets an observable that is notified when the bottom sheet has opened and appeared. */\n        MatBottomSheetRef.prototype.afterOpened = function () {\n            return this._afterOpened.asObservable();\n        };\n        /**\n         * Gets an observable that emits when the overlay's backdrop has been clicked.\n         */\n        MatBottomSheetRef.prototype.backdropClick = function () {\n            return this._overlayRef.backdropClick();\n        };\n        /**\n         * Gets an observable that emits when keydown events are targeted on the overlay.\n         */\n        MatBottomSheetRef.prototype.keydownEvents = function () {\n            return this._overlayRef.keydownEvents();\n        };\n        return MatBottomSheetRef;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n     * if any. It maintains a list of attached overlays to determine best suited overlay based\n     * on event target and order of overlay opens.\n     */\n    var OverlayKeyboardDispatcher = /** @class */ (function () {\n        function OverlayKeyboardDispatcher(document) {\n            var _this = this;\n            /** Currently attached overlays in the order they were attached. */\n            this._attachedOverlays = [];\n            /** Keyboard event listener that will be attached to the body. */\n            this._keydownListener = function (event) {\n                var overlays = _this._attachedOverlays;\n                for (var i = overlays.length - 1; i > -1; i--) {\n                    // Dispatch the keydown event to the top overlay which has subscribers to its keydown events.\n                    // We want to target the most recent overlay, rather than trying to match where the event came\n                    // from, because some components might open an overlay, but keep focus on a trigger element\n                    // (e.g. for select and autocomplete). We skip overlays without keydown event subscriptions,\n                    // because we don't want overlays that don't handle keyboard events to block the ones below\n                    // them that do.\n                    if (overlays[i]._keydownEventSubscriptions > 0) {\n                        overlays[i]._keydownEvents.next(event);\n                        break;\n                    }\n                }\n            };\n            this._document = document;\n        }\n        OverlayKeyboardDispatcher.prototype.ngOnDestroy = function () {\n            this._detach();\n        };\n        /** Add a new overlay to the list of attached overlay refs. */\n        OverlayKeyboardDispatcher.prototype.add = function (overlayRef) {\n            // Ensure that we don't get the same overlay multiple times.\n            this.remove(overlayRef);\n            // Lazily start dispatcher once first overlay is added\n            if (!this._isAttached) {\n                this._document.body.addEventListener('keydown', this._keydownListener);\n                this._isAttached = true;\n            }\n            this._attachedOverlays.push(overlayRef);\n        };\n        /** Remove an overlay from the list of attached overlay refs. */\n        OverlayKeyboardDispatcher.prototype.remove = function (overlayRef) {\n            var index = this._attachedOverlays.indexOf(overlayRef);\n            if (index > -1) {\n                this._attachedOverlays.splice(index, 1);\n            }\n            // Remove the global listener once there are no more overlays.\n            if (this._attachedOverlays.length === 0) {\n                this._detach();\n            }\n        };\n        /** Detaches the global keyboard event listener. */\n        OverlayKeyboardDispatcher.prototype._detach = function () {\n            if (this._isAttached) {\n                this._document.body.removeEventListener('keydown', this._keydownListener);\n                this._isAttached = false;\n            }\n        };\n        OverlayKeyboardDispatcher.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        OverlayKeyboardDispatcher.ctorParameters = function () { return [\n            { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] }\n        ]; };\n        OverlayKeyboardDispatcher.ɵprov = i0.ɵɵdefineInjectable({ factory: function OverlayKeyboardDispatcher_Factory() { return new OverlayKeyboardDispatcher(i0.ɵɵinject(i1.DOCUMENT)); }, token: OverlayKeyboardDispatcher, providedIn: \"root\" });\n        return OverlayKeyboardDispatcher;\n    }());\n    /** @docs-private @deprecated @breaking-change 8.0.0 */\n    function OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher, _document) {\n        return dispatcher || new OverlayKeyboardDispatcher(_document);\n    }\n    /** @docs-private @deprecated @breaking-change 8.0.0 */\n    var OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {\n        // If there is already an OverlayKeyboardDispatcher available, use that.\n        // Otherwise, provide a new one.\n        provide: OverlayKeyboardDispatcher,\n        deps: [\n            [new i0.Optional(), new i0.SkipSelf(), OverlayKeyboardDispatcher],\n            // Coerce to `InjectionToken` so that the `deps` match the \"shape\"\n            // of the type expected by Angular\n            i1.DOCUMENT\n        ],\n        useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY\n    };\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Strategy that will prevent the user from scrolling while the overlay is visible.\n     */\n    var BlockScrollStrategy = /** @class */ (function () {\n        function BlockScrollStrategy(_viewportRuler, document) {\n            this._viewportRuler = _viewportRuler;\n            this._previousHTMLStyles = { top: '', left: '' };\n            this._isEnabled = false;\n            this._document = document;\n        }\n        /** Attaches this scroll strategy to an overlay. */\n        BlockScrollStrategy.prototype.attach = function () { };\n        /** Blocks page-level scroll while the attached overlay is open. */\n        BlockScrollStrategy.prototype.enable = function () {\n            if (this._canBeEnabled()) {\n                var root = this._document.documentElement;\n                this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n                // Cache the previous inline styles in case the user had set them.\n                this._previousHTMLStyles.left = root.style.left || '';\n                this._previousHTMLStyles.top = root.style.top || '';\n                // Note: we're using the `html` node, instead of the `body`, because the `body` may\n                // have the user agent margin, whereas the `html` is guaranteed not to have one.\n                root.style.left = coercion.coerceCssPixelValue(-this._previousScrollPosition.left);\n                root.style.top = coercion.coerceCssPixelValue(-this._previousScrollPosition.top);\n                root.classList.add('cdk-global-scrollblock');\n                this._isEnabled = true;\n            }\n        };\n        /** Unblocks page-level scroll while the attached overlay is open. */\n        BlockScrollStrategy.prototype.disable = function () {\n            if (this._isEnabled) {\n                var html = this._document.documentElement;\n                var body = this._document.body;\n                var htmlStyle = html.style;\n                var bodyStyle = body.style;\n                var previousHtmlScrollBehavior = htmlStyle.scrollBehavior || '';\n                var previousBodyScrollBehavior = bodyStyle.scrollBehavior || '';\n                this._isEnabled = false;\n                htmlStyle.left = this._previousHTMLStyles.left;\n                htmlStyle.top = this._previousHTMLStyles.top;\n                html.classList.remove('cdk-global-scrollblock');\n                // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n                // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n                htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = 'auto';\n                window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n                htmlStyle.scrollBehavior = previousHtmlScrollBehavior;\n                bodyStyle.scrollBehavior = previousBodyScrollBehavior;\n            }\n        };\n        BlockScrollStrategy.prototype._canBeEnabled = function () {\n            // Since the scroll strategies can't be singletons, we have to use a global CSS class\n            // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n            // scrolling multiple times.\n            var html = this._document.documentElement;\n            if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n                return false;\n            }\n            var body = this._document.body;\n            var viewport = this._viewportRuler.getViewportSize();\n            return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n        };\n        return BlockScrollStrategy;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n     */\n    function getMatScrollStrategyAlreadyAttachedError() {\n        return Error(\"Scroll strategy has already been attached.\");\n    }\n\n    /**\n     * Strategy that will close the overlay as soon as the user starts scrolling.\n     */\n    var CloseScrollStrategy = /** @class */ (function () {\n        function CloseScrollStrategy(_scrollDispatcher, _ngZone, _viewportRuler, _config) {\n            var _this = this;\n            this._scrollDispatcher = _scrollDispatcher;\n            this._ngZone = _ngZone;\n            this._viewportRuler = _viewportRuler;\n            this._config = _config;\n            this._scrollSubscription = null;\n            /** Detaches the overlay ref and disables the scroll strategy. */\n            this._detach = function () {\n                _this.disable();\n                if (_this._overlayRef.hasAttached()) {\n                    _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n                }\n            };\n        }\n        /** Attaches this scroll strategy to an overlay. */\n        CloseScrollStrategy.prototype.attach = function (overlayRef) {\n            if (this._overlayRef) {\n                throw getMatScrollStrategyAlreadyAttachedError();\n            }\n            this._overlayRef = overlayRef;\n        };\n        /** Enables the closing of the attached overlay on scroll. */\n        CloseScrollStrategy.prototype.enable = function () {\n            var _this = this;\n            if (this._scrollSubscription) {\n                return;\n            }\n            var stream = this._scrollDispatcher.scrolled(0);\n            if (this._config && this._config.threshold && this._config.threshold > 1) {\n                this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n                this._scrollSubscription = stream.subscribe(function () {\n                    var scrollPosition = _this._viewportRuler.getViewportScrollPosition().top;\n                    if (Math.abs(scrollPosition - _this._initialScrollPosition) > _this._config.threshold) {\n                        _this._detach();\n                    }\n                    else {\n                        _this._overlayRef.updatePosition();\n                    }\n                });\n            }\n            else {\n                this._scrollSubscription = stream.subscribe(this._detach);\n            }\n        };\n        /** Disables the closing the attached overlay on scroll. */\n        CloseScrollStrategy.prototype.disable = function () {\n            if (this._scrollSubscription) {\n                this._scrollSubscription.unsubscribe();\n                this._scrollSubscription = null;\n            }\n        };\n        CloseScrollStrategy.prototype.detach = function () {\n            this.disable();\n            this._overlayRef = null;\n        };\n        return CloseScrollStrategy;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Scroll strategy that doesn't do anything. */\n    var NoopScrollStrategy = /** @class */ (function () {\n        function NoopScrollStrategy() {\n        }\n        /** Does nothing, as this scroll strategy is a no-op. */\n        NoopScrollStrategy.prototype.enable = function () { };\n        /** Does nothing, as this scroll strategy is a no-op. */\n        NoopScrollStrategy.prototype.disable = function () { };\n        /** Does nothing, as this scroll strategy is a no-op. */\n        NoopScrollStrategy.prototype.attach = function () { };\n        return NoopScrollStrategy;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // TODO(jelbourn): move this to live with the rest of the scrolling code\n    // TODO(jelbourn): someday replace this with IntersectionObservers\n    /**\n     * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n     * @param element Dimensions of the element (from getBoundingClientRect)\n     * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n     * @returns Whether the element is scrolled out of view\n     * @docs-private\n     */\n    function isElementScrolledOutsideView(element, scrollContainers) {\n        return scrollContainers.some(function (containerBounds) {\n            var outsideAbove = element.bottom < containerBounds.top;\n            var outsideBelow = element.top > containerBounds.bottom;\n            var outsideLeft = element.right < containerBounds.left;\n            var outsideRight = element.left > containerBounds.right;\n            return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n        });\n    }\n    /**\n     * Gets whether an element is clipped by any of its scrolling containers.\n     * @param element Dimensions of the element (from getBoundingClientRect)\n     * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n     * @returns Whether the element is clipped\n     * @docs-private\n     */\n    function isElementClippedByScrolling(element, scrollContainers) {\n        return scrollContainers.some(function (scrollContainerRect) {\n            var clippedAbove = element.top < scrollContainerRect.top;\n            var clippedBelow = element.bottom > scrollContainerRect.bottom;\n            var clippedLeft = element.left < scrollContainerRect.left;\n            var clippedRight = element.right > scrollContainerRect.right;\n            return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n        });\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Strategy that will update the element position as the user is scrolling.\n     */\n    var RepositionScrollStrategy = /** @class */ (function () {\n        function RepositionScrollStrategy(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n            this._scrollDispatcher = _scrollDispatcher;\n            this._viewportRuler = _viewportRuler;\n            this._ngZone = _ngZone;\n            this._config = _config;\n            this._scrollSubscription = null;\n        }\n        /** Attaches this scroll strategy to an overlay. */\n        RepositionScrollStrategy.prototype.attach = function (overlayRef) {\n            if (this._overlayRef) {\n                throw getMatScrollStrategyAlreadyAttachedError();\n            }\n            this._overlayRef = overlayRef;\n        };\n        /** Enables repositioning of the attached overlay on scroll. */\n        RepositionScrollStrategy.prototype.enable = function () {\n            var _this = this;\n            if (!this._scrollSubscription) {\n                var throttle = this._config ? this._config.scrollThrottle : 0;\n                this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(function () {\n                    _this._overlayRef.updatePosition();\n                    // TODO(crisbeto): make `close` on by default once all components can handle it.\n                    if (_this._config && _this._config.autoClose) {\n                        var overlayRect = _this._overlayRef.overlayElement.getBoundingClientRect();\n                        var _a = _this._viewportRuler.getViewportSize(), width = _a.width, height = _a.height;\n                        // TODO(crisbeto): include all ancestor scroll containers here once\n                        // we have a way of exposing the trigger element to the scroll strategy.\n                        var parentRects = [{ width: width, height: height, bottom: height, right: width, top: 0, left: 0 }];\n                        if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n                            _this.disable();\n                            _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n                        }\n                    }\n                });\n            }\n        };\n        /** Disables repositioning of the attached overlay on scroll. */\n        RepositionScrollStrategy.prototype.disable = function () {\n            if (this._scrollSubscription) {\n                this._scrollSubscription.unsubscribe();\n                this._scrollSubscription = null;\n            }\n        };\n        RepositionScrollStrategy.prototype.detach = function () {\n            this.disable();\n            this._overlayRef = null;\n        };\n        return RepositionScrollStrategy;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // Whether the current platform supports the V8 Break Iterator. The V8 check\n    // is necessary to detect all Blink based browsers.\n    var hasV8BreakIterator;\n    // We need a try/catch around the reference to `Intl`, because accessing it in some cases can\n    // cause IE to throw. These cases are tied to particular versions of Windows and can happen if\n    // the consumer is providing a polyfilled `Map`. See:\n    // https://github.com/Microsoft/ChakraCore/issues/3189\n    // https://github.com/angular/components/issues/15687\n    try {\n        hasV8BreakIterator = (typeof Intl !== 'undefined' && Intl.v8BreakIterator);\n    }\n    catch (_a) {\n        hasV8BreakIterator = false;\n    }\n    /**\n     * Service to detect the current platform by comparing the userAgent strings and\n     * checking browser-specific global properties.\n     */\n    var Platform = /** @class */ (function () {\n        /**\n         * @breaking-change 8.0.0 remove optional decorator\n         */\n        function Platform(_platformId) {\n            this._platformId = _platformId;\n            // We want to use the Angular platform check because if the Document is shimmed\n            // without the navigator, the following checks will fail. This is preferred because\n            // sometimes the Document may be shimmed without the user's knowledge or intention\n            /** Whether the Angular application is being rendered in the browser. */\n            this.isBrowser = this._platformId ?\n                i1.isPlatformBrowser(this._platformId) : typeof document === 'object' && !!document;\n            /** Whether the current browser is Microsoft Edge. */\n            this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n            /** Whether the current rendering engine is Microsoft Trident. */\n            this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n            // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\n            /** Whether the current rendering engine is Blink. */\n            this.BLINK = this.isBrowser && (!!(window.chrome || hasV8BreakIterator) &&\n                typeof CSS !== 'undefined' && !this.EDGE && !this.TRIDENT);\n            // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\n            // ensure that Webkit runs standalone and is not used as another engine's base.\n            /** Whether the current rendering engine is WebKit. */\n            this.WEBKIT = this.isBrowser &&\n                /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n            /** Whether the current platform is Apple iOS. */\n            this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n                !('MSStream' in window);\n            // It's difficult to detect the plain Gecko engine, because most of the browsers identify\n            // them self as Gecko-like browsers and modify the userAgent's according to that.\n            // Since we only cover one explicit Firefox case, we can simply check for Firefox\n            // instead of having an unstable check for Gecko.\n            /** Whether the current browser is Firefox. */\n            this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n            /** Whether the current platform is Android. */\n            // Trident on mobile adds the android platform to the userAgent to trick detections.\n            this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n            // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\n            // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\n            // Safari browser should also use Webkit as its layout engine.\n            /** Whether the current browser is Safari. */\n            this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n        }\n        Platform.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        Platform.ctorParameters = function () { return [\n            { type: Object, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [i0.PLATFORM_ID,] }] }\n        ]; };\n        Platform.ɵprov = i0.ɵɵdefineInjectable({ factory: function Platform_Factory() { return new Platform(i0.ɵɵinject(i0.PLATFORM_ID, 8)); }, token: Platform, providedIn: \"root\" });\n        return Platform;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Time in ms to throttle the scrolling events by default. */\n    var DEFAULT_SCROLL_TIME = 20;\n    /**\n     * Service contained all registered Scrollable references and emits an event when any one of the\n     * Scrollable references emit a scrolled event.\n     */\n    var ScrollDispatcher = /** @class */ (function () {\n        function ScrollDispatcher(_ngZone, _platform) {\n            this._ngZone = _ngZone;\n            this._platform = _platform;\n            /** Subject for notifying that a registered scrollable reference element has been scrolled. */\n            this._scrolled = new rxjs.Subject();\n            /** Keeps track of the global `scroll` and `resize` subscriptions. */\n            this._globalSubscription = null;\n            /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */\n            this._scrolledCount = 0;\n            /**\n             * Map of all the scrollable references that are registered with the service and their\n             * scroll event subscriptions.\n             */\n            this.scrollContainers = new Map();\n        }\n        /**\n         * Registers a scrollable instance with the service and listens for its scrolled events. When the\n         * scrollable is scrolled, the service emits the event to its scrolled observable.\n         * @param scrollable Scrollable instance to be registered.\n         */\n        ScrollDispatcher.prototype.register = function (scrollable) {\n            var _this = this;\n            if (!this.scrollContainers.has(scrollable)) {\n                this.scrollContainers.set(scrollable, scrollable.elementScrolled()\n                    .subscribe(function () { return _this._scrolled.next(scrollable); }));\n            }\n        };\n        /**\n         * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n         * @param scrollable Scrollable instance to be deregistered.\n         */\n        ScrollDispatcher.prototype.deregister = function (scrollable) {\n            var scrollableReference = this.scrollContainers.get(scrollable);\n            if (scrollableReference) {\n                scrollableReference.unsubscribe();\n                this.scrollContainers.delete(scrollable);\n            }\n        };\n        /**\n         * Returns an observable that emits an event whenever any of the registered Scrollable\n         * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n         * to override the default \"throttle\" time.\n         *\n         * **Note:** in order to avoid hitting change detection for every scroll event,\n         * all of the events emitted from this stream will be run outside the Angular zone.\n         * If you need to update any data bindings as a result of a scroll event, you have\n         * to run the callback using `NgZone.run`.\n         */\n        ScrollDispatcher.prototype.scrolled = function (auditTimeInMs) {\n            var _this = this;\n            if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_SCROLL_TIME; }\n            if (!this._platform.isBrowser) {\n                return rxjs.of();\n            }\n            return new rxjs.Observable(function (observer) {\n                if (!_this._globalSubscription) {\n                    _this._addGlobalListener();\n                }\n                // In the case of a 0ms delay, use an observable without auditTime\n                // since it does add a perceptible delay in processing overhead.\n                var subscription = auditTimeInMs > 0 ?\n                    _this._scrolled.pipe(operators.auditTime(auditTimeInMs)).subscribe(observer) :\n                    _this._scrolled.subscribe(observer);\n                _this._scrolledCount++;\n                return function () {\n                    subscription.unsubscribe();\n                    _this._scrolledCount--;\n                    if (!_this._scrolledCount) {\n                        _this._removeGlobalListener();\n                    }\n                };\n            });\n        };\n        ScrollDispatcher.prototype.ngOnDestroy = function () {\n            var _this = this;\n            this._removeGlobalListener();\n            this.scrollContainers.forEach(function (_, container) { return _this.deregister(container); });\n            this._scrolled.complete();\n        };\n        /**\n         * Returns an observable that emits whenever any of the\n         * scrollable ancestors of an element are scrolled.\n         * @param elementRef Element whose ancestors to listen for.\n         * @param auditTimeInMs Time to throttle the scroll events.\n         */\n        ScrollDispatcher.prototype.ancestorScrolled = function (elementRef, auditTimeInMs) {\n            var ancestors = this.getAncestorScrollContainers(elementRef);\n            return this.scrolled(auditTimeInMs).pipe(operators.filter(function (target) {\n                return !target || ancestors.indexOf(target) > -1;\n            }));\n        };\n        /** Returns all registered Scrollables that contain the provided element. */\n        ScrollDispatcher.prototype.getAncestorScrollContainers = function (elementRef) {\n            var _this = this;\n            var scrollingContainers = [];\n            this.scrollContainers.forEach(function (_subscription, scrollable) {\n                if (_this._scrollableContainsElement(scrollable, elementRef)) {\n                    scrollingContainers.push(scrollable);\n                }\n            });\n            return scrollingContainers;\n        };\n        /** Returns true if the element is contained within the provided Scrollable. */\n        ScrollDispatcher.prototype._scrollableContainsElement = function (scrollable, elementRef) {\n            var element = elementRef.nativeElement;\n            var scrollableElement = scrollable.getElementRef().nativeElement;\n            // Traverse through the element parents until we reach null, checking if any of the elements\n            // are the scrollable's element.\n            do {\n                if (element == scrollableElement) {\n                    return true;\n                }\n            } while (element = element.parentElement);\n            return false;\n        };\n        /** Sets up the global scroll listeners. */\n        ScrollDispatcher.prototype._addGlobalListener = function () {\n            var _this = this;\n            this._globalSubscription = this._ngZone.runOutsideAngular(function () {\n                return rxjs.fromEvent(window.document, 'scroll').subscribe(function () { return _this._scrolled.next(); });\n            });\n        };\n        /** Cleans up the global scroll listener. */\n        ScrollDispatcher.prototype._removeGlobalListener = function () {\n            if (this._globalSubscription) {\n                this._globalSubscription.unsubscribe();\n                this._globalSubscription = null;\n            }\n        };\n        ScrollDispatcher.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        ScrollDispatcher.ctorParameters = function () { return [\n            { type: i0.NgZone },\n            { type: platform.Platform }\n        ]; };\n        ScrollDispatcher.ɵprov = i0.ɵɵdefineInjectable({ factory: function ScrollDispatcher_Factory() { return new ScrollDispatcher(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(Platform)); }, token: ScrollDispatcher, providedIn: \"root\" });\n        return ScrollDispatcher;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Time in ms to throttle the resize events by default. */\n    var DEFAULT_RESIZE_TIME = 20;\n    /**\n     * Simple utility for getting the bounds of the browser viewport.\n     * @docs-private\n     */\n    var ViewportRuler = /** @class */ (function () {\n        function ViewportRuler(_platform, ngZone) {\n            var _this = this;\n            this._platform = _platform;\n            ngZone.runOutsideAngular(function () {\n                _this._change = _platform.isBrowser ?\n                    rxjs.merge(rxjs.fromEvent(window, 'resize'), rxjs.fromEvent(window, 'orientationchange')) :\n                    rxjs.of();\n                // Note that we need to do the subscription inside `runOutsideAngular`\n                // since subscribing is what causes the event listener to be added.\n                _this._invalidateCache = _this.change().subscribe(function () { return _this._updateViewportSize(); });\n            });\n        }\n        ViewportRuler.prototype.ngOnDestroy = function () {\n            this._invalidateCache.unsubscribe();\n        };\n        /** Returns the viewport's width and height. */\n        ViewportRuler.prototype.getViewportSize = function () {\n            if (!this._viewportSize) {\n                this._updateViewportSize();\n            }\n            var output = { width: this._viewportSize.width, height: this._viewportSize.height };\n            // If we're not on a browser, don't cache the size since it'll be mocked out anyway.\n            if (!this._platform.isBrowser) {\n                this._viewportSize = null;\n            }\n            return output;\n        };\n        /** Gets a ClientRect for the viewport's bounds. */\n        ViewportRuler.prototype.getViewportRect = function () {\n            // Use the document element's bounding rect rather than the window scroll properties\n            // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n            // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n            // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n            // can disagree when the page is pinch-zoomed (on devices that support touch).\n            // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n            // We use the documentElement instead of the body because, by default (without a css reset)\n            // browsers typically give the document body an 8px margin, which is not included in\n            // getBoundingClientRect().\n            var scrollPosition = this.getViewportScrollPosition();\n            var _a = this.getViewportSize(), width = _a.width, height = _a.height;\n            return {\n                top: scrollPosition.top,\n                left: scrollPosition.left,\n                bottom: scrollPosition.top + height,\n                right: scrollPosition.left + width,\n                height: height,\n                width: width,\n            };\n        };\n        /** Gets the (top, left) scroll position of the viewport. */\n        ViewportRuler.prototype.getViewportScrollPosition = function () {\n            // While we can get a reference to the fake document\n            // during SSR, it doesn't have getBoundingClientRect.\n            if (!this._platform.isBrowser) {\n                return { top: 0, left: 0 };\n            }\n            // The top-left-corner of the viewport is determined by the scroll position of the document\n            // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n            // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n            // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n            // `document.documentElement` works consistently, where the `top` and `left` values will\n            // equal negative the scroll position.\n            var documentElement = document.documentElement;\n            var documentRect = documentElement.getBoundingClientRect();\n            var top = -documentRect.top || document.body.scrollTop || window.scrollY ||\n                documentElement.scrollTop || 0;\n            var left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\n                documentElement.scrollLeft || 0;\n            return { top: top, left: left };\n        };\n        /**\n         * Returns a stream that emits whenever the size of the viewport changes.\n         * @param throttleTime Time in milliseconds to throttle the stream.\n         */\n        ViewportRuler.prototype.change = function (throttleTime) {\n            if (throttleTime === void 0) { throttleTime = DEFAULT_RESIZE_TIME; }\n            return throttleTime > 0 ? this._change.pipe(operators.auditTime(throttleTime)) : this._change;\n        };\n        /** Updates the cached viewport size. */\n        ViewportRuler.prototype._updateViewportSize = function () {\n            this._viewportSize = this._platform.isBrowser ?\n                { width: window.innerWidth, height: window.innerHeight } :\n                { width: 0, height: 0 };\n        };\n        ViewportRuler.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        ViewportRuler.ctorParameters = function () { return [\n            { type: platform.Platform },\n            { type: i0.NgZone }\n        ]; };\n        ViewportRuler.ɵprov = i0.ɵɵdefineInjectable({ factory: function ViewportRuler_Factory() { return new ViewportRuler(i0.ɵɵinject(Platform), i0.ɵɵinject(i0.NgZone)); }, token: ViewportRuler, providedIn: \"root\" });\n        return ViewportRuler;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Options for how an overlay will handle scrolling.\n     *\n     * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n     * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n     */\n    var ScrollStrategyOptions = /** @class */ (function () {\n        function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler, _ngZone, document) {\n            var _this = this;\n            this._scrollDispatcher = _scrollDispatcher;\n            this._viewportRuler = _viewportRuler;\n            this._ngZone = _ngZone;\n            /** Do nothing on scroll. */\n            this.noop = function () { return new NoopScrollStrategy(); };\n            /**\n             * Close the overlay as soon as the user scrolls.\n             * @param config Configuration to be used inside the scroll strategy.\n             */\n            this.close = function (config) { return new CloseScrollStrategy(_this._scrollDispatcher, _this._ngZone, _this._viewportRuler, config); };\n            /** Block scrolling. */\n            this.block = function () { return new BlockScrollStrategy(_this._viewportRuler, _this._document); };\n            /**\n             * Update the overlay's position on scroll.\n             * @param config Configuration to be used inside the scroll strategy.\n             * Allows debouncing the reposition calls.\n             */\n            this.reposition = function (config) { return new RepositionScrollStrategy(_this._scrollDispatcher, _this._viewportRuler, _this._ngZone, config); };\n            this._document = document;\n        }\n        ScrollStrategyOptions.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        ScrollStrategyOptions.ctorParameters = function () { return [\n            { type: scrolling.ScrollDispatcher },\n            { type: scrolling.ViewportRuler },\n            { type: i0.NgZone },\n            { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] }\n        ]; };\n        ScrollStrategyOptions.ɵprov = i0.ɵɵdefineInjectable({ factory: function ScrollStrategyOptions_Factory() { return new ScrollStrategyOptions(i0.ɵɵinject(ScrollDispatcher), i0.ɵɵinject(ViewportRuler), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.DOCUMENT)); }, token: ScrollStrategyOptions, providedIn: \"root\" });\n        return ScrollStrategyOptions;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Initial configuration used when creating an overlay. */\n    var OverlayConfig = /** @class */ (function () {\n        function OverlayConfig(config) {\n            var e_1, _a;\n            /** Strategy to be used when handling scroll events while the overlay is open. */\n            this.scrollStrategy = new NoopScrollStrategy();\n            /** Custom class to add to the overlay pane. */\n            this.panelClass = '';\n            /** Whether the overlay has a backdrop. */\n            this.hasBackdrop = false;\n            /** Custom class to add to the backdrop */\n            this.backdropClass = 'cdk-overlay-dark-backdrop';\n            /**\n             * Whether the overlay should be disposed of when the user goes backwards/forwards in history.\n             * Note that this usually doesn't include clicking on links (unless the user is using\n             * the `HashLocationStrategy`).\n             */\n            this.disposeOnNavigation = false;\n            if (config) {\n                // Use `Iterable` instead of `Array` because TypeScript, as of 3.6.3,\n                // loses the array generic type in the `for of`. But we *also* have to use `Array` because\n                // typescript won't iterate over an `Iterable` unless you compile with `--downlevelIteration`\n                var configKeys = Object.keys(config);\n                try {\n                    for (var configKeys_1 = tslib.__values(configKeys), configKeys_1_1 = configKeys_1.next(); !configKeys_1_1.done; configKeys_1_1 = configKeys_1.next()) {\n                        var key = configKeys_1_1.value;\n                        if (config[key] !== undefined) {\n                            // TypeScript, as of version 3.5, sees the left-hand-side of this expression\n                            // as \"I don't know *which* key this is, so the only valid value is the intersection\n                            // of all the posible values.\" In this case, that happens to be `undefined`. TypeScript\n                            // is not smart enough to see that the right-hand-side is actually an access of the same\n                            // exact type with the same exact key, meaning that the value type must be identical.\n                            // So we use `any` to work around this.\n                            this[key] = config[key];\n                        }\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (configKeys_1_1 && !configKeys_1_1.done && (_a = configKeys_1.return)) _a.call(configKeys_1);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }\n        }\n        return OverlayConfig;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Container inside which all overlays will render. */\n    var OverlayContainer = /** @class */ (function () {\n        function OverlayContainer(document) {\n            this._document = document;\n        }\n        OverlayContainer.prototype.ngOnDestroy = function () {\n            if (this._containerElement && this._containerElement.parentNode) {\n                this._containerElement.parentNode.removeChild(this._containerElement);\n            }\n        };\n        /**\n         * This method returns the overlay container element. It will lazily\n         * create the element the first time  it is called to facilitate using\n         * the container in non-browser environments.\n         * @returns the container element\n         */\n        OverlayContainer.prototype.getContainerElement = function () {\n            if (!this._containerElement) {\n                this._createContainer();\n            }\n            return this._containerElement;\n        };\n        /**\n         * Create the overlay container element, which is simply a div\n         * with the 'cdk-overlay-container' class on the document body.\n         */\n        OverlayContainer.prototype._createContainer = function () {\n            var containerClass = 'cdk-overlay-container';\n            var previousContainers = this._document.getElementsByClassName(containerClass);\n            // Remove any old containers. This can happen when transitioning from the server to the client.\n            for (var i = 0; i < previousContainers.length; i++) {\n                previousContainers[i].parentNode.removeChild(previousContainers[i]);\n            }\n            var container = this._document.createElement('div');\n            container.classList.add(containerClass);\n            this._document.body.appendChild(container);\n            this._containerElement = container;\n        };\n        OverlayContainer.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        OverlayContainer.ctorParameters = function () { return [\n            { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] }\n        ]; };\n        OverlayContainer.ɵprov = i0.ɵɵdefineInjectable({ factory: function OverlayContainer_Factory() { return new OverlayContainer(i0.ɵɵinject(i1.DOCUMENT)); }, token: OverlayContainer, providedIn: \"root\" });\n        return OverlayContainer;\n    }());\n    /** @docs-private @deprecated @breaking-change 8.0.0 */\n    function OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer, _document) {\n        return parentContainer || new OverlayContainer(_document);\n    }\n    /** @docs-private @deprecated @breaking-change 8.0.0 */\n    var OVERLAY_CONTAINER_PROVIDER = {\n        // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\n        provide: OverlayContainer,\n        deps: [\n            [new i0.Optional(), new i0.SkipSelf(), OverlayContainer],\n            i1.DOCUMENT // We need to use the InjectionToken somewhere to keep TS happy\n        ],\n        useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\n    };\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Reference to an overlay that has been created with the Overlay service.\n     * Used to manipulate or dispose of said overlay.\n     */\n    var OverlayRef = /** @class */ (function () {\n        function OverlayRef(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document, \n        // @breaking-change 8.0.0 `_location` parameter to be made required.\n        _location) {\n            var _this = this;\n            this._portalOutlet = _portalOutlet;\n            this._host = _host;\n            this._pane = _pane;\n            this._config = _config;\n            this._ngZone = _ngZone;\n            this._keyboardDispatcher = _keyboardDispatcher;\n            this._document = _document;\n            this._location = _location;\n            this._backdropElement = null;\n            this._backdropClick = new rxjs.Subject();\n            this._attachments = new rxjs.Subject();\n            this._detachments = new rxjs.Subject();\n            this._locationChanges = rxjs.Subscription.EMPTY;\n            this._backdropClickHandler = function (event) { return _this._backdropClick.next(event); };\n            this._keydownEventsObservable = new rxjs.Observable(function (observer) {\n                var subscription = _this._keydownEvents.subscribe(observer);\n                _this._keydownEventSubscriptions++;\n                return function () {\n                    subscription.unsubscribe();\n                    _this._keydownEventSubscriptions--;\n                };\n            });\n            /** Stream of keydown events dispatched to this overlay. */\n            this._keydownEvents = new rxjs.Subject();\n            /** Amount of subscriptions to the keydown events. */\n            this._keydownEventSubscriptions = 0;\n            if (_config.scrollStrategy) {\n                this._scrollStrategy = _config.scrollStrategy;\n                this._scrollStrategy.attach(this);\n            }\n            this._positionStrategy = _config.positionStrategy;\n        }\n        Object.defineProperty(OverlayRef.prototype, \"overlayElement\", {\n            /** The overlay's HTML element */\n            get: function () {\n                return this._pane;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(OverlayRef.prototype, \"backdropElement\", {\n            /** The overlay's backdrop HTML element. */\n            get: function () {\n                return this._backdropElement;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(OverlayRef.prototype, \"hostElement\", {\n            /**\n             * Wrapper around the panel element. Can be used for advanced\n             * positioning where a wrapper with specific styling is\n             * required around the overlay pane.\n             */\n            get: function () {\n                return this._host;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Attaches content, given via a Portal, to the overlay.\n         * If the overlay is configured to have a backdrop, it will be created.\n         *\n         * @param portal Portal instance to which to attach the overlay.\n         * @returns The portal attachment result.\n         */\n        OverlayRef.prototype.attach = function (portal) {\n            var _this = this;\n            var attachResult = this._portalOutlet.attach(portal);\n            if (this._positionStrategy) {\n                this._positionStrategy.attach(this);\n            }\n            // Update the pane element with the given configuration.\n            if (!this._host.parentElement && this._previousHostParent) {\n                this._previousHostParent.appendChild(this._host);\n            }\n            this._updateStackingOrder();\n            this._updateElementSize();\n            this._updateElementDirection();\n            if (this._scrollStrategy) {\n                this._scrollStrategy.enable();\n            }\n            // Update the position once the zone is stable so that the overlay will be fully rendered\n            // before attempting to position it, as the position may depend on the size of the rendered\n            // content.\n            this._ngZone.onStable\n                .asObservable()\n                .pipe(operators.take(1))\n                .subscribe(function () {\n                // The overlay could've been detached before the zone has stabilized.\n                if (_this.hasAttached()) {\n                    _this.updatePosition();\n                }\n            });\n            // Enable pointer events for the overlay pane element.\n            this._togglePointerEvents(true);\n            if (this._config.hasBackdrop) {\n                this._attachBackdrop();\n            }\n            if (this._config.panelClass) {\n                this._toggleClasses(this._pane, this._config.panelClass, true);\n            }\n            // Only emit the `attachments` event once all other setup is done.\n            this._attachments.next();\n            // Track this overlay by the keyboard dispatcher\n            this._keyboardDispatcher.add(this);\n            // @breaking-change 8.0.0 remove the null check for `_location`\n            // once the constructor parameter is made required.\n            if (this._config.disposeOnNavigation && this._location) {\n                this._locationChanges = this._location.subscribe(function () { return _this.dispose(); });\n            }\n            return attachResult;\n        };\n        /**\n         * Detaches an overlay from a portal.\n         * @returns The portal detachment result.\n         */\n        OverlayRef.prototype.detach = function () {\n            if (!this.hasAttached()) {\n                return;\n            }\n            this.detachBackdrop();\n            // When the overlay is detached, the pane element should disable pointer events.\n            // This is necessary because otherwise the pane element will cover the page and disable\n            // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n            this._togglePointerEvents(false);\n            if (this._positionStrategy && this._positionStrategy.detach) {\n                this._positionStrategy.detach();\n            }\n            if (this._scrollStrategy) {\n                this._scrollStrategy.disable();\n            }\n            var detachmentResult = this._portalOutlet.detach();\n            // Only emit after everything is detached.\n            this._detachments.next();\n            // Remove this overlay from keyboard dispatcher tracking.\n            this._keyboardDispatcher.remove(this);\n            // Keeping the host element in the DOM can cause scroll jank, because it still gets\n            // rendered, even though it's transparent and unclickable which is why we remove it.\n            this._detachContentWhenStable();\n            // Stop listening for location changes.\n            this._locationChanges.unsubscribe();\n            return detachmentResult;\n        };\n        /** Cleans up the overlay from the DOM. */\n        OverlayRef.prototype.dispose = function () {\n            var isAttached = this.hasAttached();\n            if (this._positionStrategy) {\n                this._positionStrategy.dispose();\n            }\n            this._disposeScrollStrategy();\n            this.detachBackdrop();\n            this._locationChanges.unsubscribe();\n            this._keyboardDispatcher.remove(this);\n            this._portalOutlet.dispose();\n            this._attachments.complete();\n            this._backdropClick.complete();\n            this._keydownEvents.complete();\n            if (this._host && this._host.parentNode) {\n                this._host.parentNode.removeChild(this._host);\n                this._host = null;\n            }\n            this._previousHostParent = this._pane = null;\n            if (isAttached) {\n                this._detachments.next();\n            }\n            this._detachments.complete();\n        };\n        /** Whether the overlay has attached content. */\n        OverlayRef.prototype.hasAttached = function () {\n            return this._portalOutlet.hasAttached();\n        };\n        /** Gets an observable that emits when the backdrop has been clicked. */\n        OverlayRef.prototype.backdropClick = function () {\n            return this._backdropClick.asObservable();\n        };\n        /** Gets an observable that emits when the overlay has been attached. */\n        OverlayRef.prototype.attachments = function () {\n            return this._attachments.asObservable();\n        };\n        /** Gets an observable that emits when the overlay has been detached. */\n        OverlayRef.prototype.detachments = function () {\n            return this._detachments.asObservable();\n        };\n        /** Gets an observable of keydown events targeted to this overlay. */\n        OverlayRef.prototype.keydownEvents = function () {\n            return this._keydownEventsObservable;\n        };\n        /** Gets the current overlay configuration, which is immutable. */\n        OverlayRef.prototype.getConfig = function () {\n            return this._config;\n        };\n        /** Updates the position of the overlay based on the position strategy. */\n        OverlayRef.prototype.updatePosition = function () {\n            if (this._positionStrategy) {\n                this._positionStrategy.apply();\n            }\n        };\n        /** Switches to a new position strategy and updates the overlay position. */\n        OverlayRef.prototype.updatePositionStrategy = function (strategy) {\n            if (strategy === this._positionStrategy) {\n                return;\n            }\n            if (this._positionStrategy) {\n                this._positionStrategy.dispose();\n            }\n            this._positionStrategy = strategy;\n            if (this.hasAttached()) {\n                strategy.attach(this);\n                this.updatePosition();\n            }\n        };\n        /** Update the size properties of the overlay. */\n        OverlayRef.prototype.updateSize = function (sizeConfig) {\n            this._config = tslib.__assign(tslib.__assign({}, this._config), sizeConfig);\n            this._updateElementSize();\n        };\n        /** Sets the LTR/RTL direction for the overlay. */\n        OverlayRef.prototype.setDirection = function (dir) {\n            this._config = tslib.__assign(tslib.__assign({}, this._config), { direction: dir });\n            this._updateElementDirection();\n        };\n        /** Add a CSS class or an array of classes to the overlay pane. */\n        OverlayRef.prototype.addPanelClass = function (classes) {\n            if (this._pane) {\n                this._toggleClasses(this._pane, classes, true);\n            }\n        };\n        /** Remove a CSS class or an array of classes from the overlay pane. */\n        OverlayRef.prototype.removePanelClass = function (classes) {\n            if (this._pane) {\n                this._toggleClasses(this._pane, classes, false);\n            }\n        };\n        /**\n         * Returns the layout direction of the overlay panel.\n         */\n        OverlayRef.prototype.getDirection = function () {\n            var direction = this._config.direction;\n            if (!direction) {\n                return 'ltr';\n            }\n            return typeof direction === 'string' ? direction : direction.value;\n        };\n        /** Switches to a new scroll strategy. */\n        OverlayRef.prototype.updateScrollStrategy = function (strategy) {\n            if (strategy === this._scrollStrategy) {\n                return;\n            }\n            this._disposeScrollStrategy();\n            this._scrollStrategy = strategy;\n            if (this.hasAttached()) {\n                strategy.attach(this);\n                strategy.enable();\n            }\n        };\n        /** Updates the text direction of the overlay panel. */\n        OverlayRef.prototype._updateElementDirection = function () {\n            this._host.setAttribute('dir', this.getDirection());\n        };\n        /** Updates the size of the overlay element based on the overlay config. */\n        OverlayRef.prototype._updateElementSize = function () {\n            if (!this._pane) {\n                return;\n            }\n            var style = this._pane.style;\n            style.width = coercion.coerceCssPixelValue(this._config.width);\n            style.height = coercion.coerceCssPixelValue(this._config.height);\n            style.minWidth = coercion.coerceCssPixelValue(this._config.minWidth);\n            style.minHeight = coercion.coerceCssPixelValue(this._config.minHeight);\n            style.maxWidth = coercion.coerceCssPixelValue(this._config.maxWidth);\n            style.maxHeight = coercion.coerceCssPixelValue(this._config.maxHeight);\n        };\n        /** Toggles the pointer events for the overlay pane element. */\n        OverlayRef.prototype._togglePointerEvents = function (enablePointer) {\n            this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\n        };\n        /** Attaches a backdrop for this overlay. */\n        OverlayRef.prototype._attachBackdrop = function () {\n            var _this = this;\n            var showingClass = 'cdk-overlay-backdrop-showing';\n            this._backdropElement = this._document.createElement('div');\n            this._backdropElement.classList.add('cdk-overlay-backdrop');\n            if (this._config.backdropClass) {\n                this._toggleClasses(this._backdropElement, this._config.backdropClass, true);\n            }\n            // Insert the backdrop before the pane in the DOM order,\n            // in order to handle stacked overlays properly.\n            this._host.parentElement.insertBefore(this._backdropElement, this._host);\n            // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n            // action desired when such a click occurs (usually closing the overlay).\n            this._backdropElement.addEventListener('click', this._backdropClickHandler);\n            // Add class to fade-in the backdrop after one frame.\n            if (typeof requestAnimationFrame !== 'undefined') {\n                this._ngZone.runOutsideAngular(function () {\n                    requestAnimationFrame(function () {\n                        if (_this._backdropElement) {\n                            _this._backdropElement.classList.add(showingClass);\n                        }\n                    });\n                });\n            }\n            else {\n                this._backdropElement.classList.add(showingClass);\n            }\n        };\n        /**\n         * Updates the stacking order of the element, moving it to the top if necessary.\n         * This is required in cases where one overlay was detached, while another one,\n         * that should be behind it, was destroyed. The next time both of them are opened,\n         * the stacking will be wrong, because the detached element's pane will still be\n         * in its original DOM position.\n         */\n        OverlayRef.prototype._updateStackingOrder = function () {\n            if (this._host.nextSibling) {\n                this._host.parentNode.appendChild(this._host);\n            }\n        };\n        /** Detaches the backdrop (if any) associated with the overlay. */\n        OverlayRef.prototype.detachBackdrop = function () {\n            var _this = this;\n            var backdropToDetach = this._backdropElement;\n            if (!backdropToDetach) {\n                return;\n            }\n            var timeoutId;\n            var finishDetach = function () {\n                // It may not be attached to anything in certain cases (e.g. unit tests).\n                if (backdropToDetach) {\n                    backdropToDetach.removeEventListener('click', _this._backdropClickHandler);\n                    backdropToDetach.removeEventListener('transitionend', finishDetach);\n                    if (backdropToDetach.parentNode) {\n                        backdropToDetach.parentNode.removeChild(backdropToDetach);\n                    }\n                }\n                // It is possible that a new portal has been attached to this overlay since we started\n                // removing the backdrop. If that is the case, only clear the backdrop reference if it\n                // is still the same instance that we started to remove.\n                if (_this._backdropElement == backdropToDetach) {\n                    _this._backdropElement = null;\n                }\n                if (_this._config.backdropClass) {\n                    _this._toggleClasses(backdropToDetach, _this._config.backdropClass, false);\n                }\n                clearTimeout(timeoutId);\n            };\n            backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n            this._ngZone.runOutsideAngular(function () {\n                backdropToDetach.addEventListener('transitionend', finishDetach);\n            });\n            // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n            // In this case we make it unclickable and we try to remove it after a delay.\n            backdropToDetach.style.pointerEvents = 'none';\n            // Run this outside the Angular zone because there's nothing that Angular cares about.\n            // If it were to run inside the Angular zone, every test that used Overlay would have to be\n            // either async or fakeAsync.\n            timeoutId = this._ngZone.runOutsideAngular(function () { return setTimeout(finishDetach, 500); });\n        };\n        /** Toggles a single CSS class or an array of classes on an element. */\n        OverlayRef.prototype._toggleClasses = function (element, cssClasses, isAdd) {\n            var classList = element.classList;\n            coercion.coerceArray(cssClasses).forEach(function (cssClass) {\n                // We can't do a spread here, because IE doesn't support setting multiple classes.\n                // Also trying to add an empty string to a DOMTokenList will throw.\n                if (cssClass) {\n                    isAdd ? classList.add(cssClass) : classList.remove(cssClass);\n                }\n            });\n        };\n        /** Detaches the overlay content next time the zone stabilizes. */\n        OverlayRef.prototype._detachContentWhenStable = function () {\n            var _this = this;\n            // Normally we wouldn't have to explicitly run this outside the `NgZone`, however\n            // if the consumer is using `zone-patch-rxjs`, the `Subscription.unsubscribe` call will\n            // be patched to run inside the zone, which will throw us into an infinite loop.\n            this._ngZone.runOutsideAngular(function () {\n                // We can't remove the host here immediately, because the overlay pane's content\n                // might still be animating. This stream helps us avoid interrupting the animation\n                // by waiting for the pane to become empty.\n                var subscription = _this._ngZone.onStable\n                    .asObservable()\n                    .pipe(operators.takeUntil(rxjs.merge(_this._attachments, _this._detachments)))\n                    .subscribe(function () {\n                    // Needs a couple of checks for the pane and host, because\n                    // they may have been removed by the time the zone stabilizes.\n                    if (!_this._pane || !_this._host || _this._pane.children.length === 0) {\n                        if (_this._pane && _this._config.panelClass) {\n                            _this._toggleClasses(_this._pane, _this._config.panelClass, false);\n                        }\n                        if (_this._host && _this._host.parentElement) {\n                            _this._previousHostParent = _this._host.parentElement;\n                            _this._previousHostParent.removeChild(_this._host);\n                        }\n                        subscription.unsubscribe();\n                    }\n                });\n            });\n        };\n        /** Disposes of a scroll strategy. */\n        OverlayRef.prototype._disposeScrollStrategy = function () {\n            var scrollStrategy = this._scrollStrategy;\n            if (scrollStrategy) {\n                scrollStrategy.disable();\n                if (scrollStrategy.detach) {\n                    scrollStrategy.detach();\n                }\n            }\n        };\n        return OverlayRef;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** The points of the origin element and the overlay element to connect. */\n    var ConnectionPositionPair = /** @class */ (function () {\n        function ConnectionPositionPair(origin, overlay, \n        /** Offset along the X axis. */\n        offsetX, \n        /** Offset along the Y axis. */\n        offsetY, \n        /** Class(es) to be applied to the panel while this position is active. */\n        panelClass) {\n            this.offsetX = offsetX;\n            this.offsetY = offsetY;\n            this.panelClass = panelClass;\n            this.originX = origin.originX;\n            this.originY = origin.originY;\n            this.overlayX = overlay.overlayX;\n            this.overlayY = overlay.overlayY;\n        }\n        return ConnectionPositionPair;\n    }());\n    /**\n     * Set of properties regarding the position of the origin and overlay relative to the viewport\n     * with respect to the containing Scrollable elements.\n     *\n     * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n     * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n     *\n     * The overlay and origin are outside view if there is no overlap between their bounding client\n     * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n     *\n     *       -----------                    -----------\n     *       | outside |                    | clipped |\n     *       |  view   |              --------------------------\n     *       |         |              |     |         |        |\n     *       ----------               |     -----------        |\n     *  --------------------------    |                        |\n     *  |                        |    |      Scrollable        |\n     *  |                        |    |                        |\n     *  |                        |     --------------------------\n     *  |      Scrollable        |\n     *  |                        |\n     *  --------------------------\n     *\n     *  @docs-private\n     */\n    var ScrollingVisibility = /** @class */ (function () {\n        function ScrollingVisibility() {\n        }\n        return ScrollingVisibility;\n    }());\n    /** The change event emitted by the strategy when a fallback position is used. */\n    var ConnectedOverlayPositionChange = /** @class */ (function () {\n        function ConnectedOverlayPositionChange(\n        /** The position used as a result of this change. */\n        connectionPair, \n        /** @docs-private */\n        scrollableViewProperties) {\n            this.connectionPair = connectionPair;\n            this.scrollableViewProperties = scrollableViewProperties;\n        }\n        /** @nocollapse */\n        ConnectedOverlayPositionChange.ctorParameters = function () { return [\n            { type: ConnectionPositionPair },\n            { type: ScrollingVisibility, decorators: [{ type: i0.Optional }] }\n        ]; };\n        return ConnectedOverlayPositionChange;\n    }());\n    /**\n     * Validates whether a vertical position property matches the expected values.\n     * @param property Name of the property being validated.\n     * @param value Value of the property being validated.\n     * @docs-private\n     */\n    function validateVerticalPosition(property, value) {\n        if (value !== 'top' && value !== 'bottom' && value !== 'center') {\n            throw Error(\"ConnectedPosition: Invalid \" + property + \" \\\"\" + value + \"\\\". \" +\n                \"Expected \\\"top\\\", \\\"bottom\\\" or \\\"center\\\".\");\n        }\n    }\n    /**\n     * Validates whether a horizontal position property matches the expected values.\n     * @param property Name of the property being validated.\n     * @param value Value of the property being validated.\n     * @docs-private\n     */\n    function validateHorizontalPosition(property, value) {\n        if (value !== 'start' && value !== 'end' && value !== 'center') {\n            throw Error(\"ConnectedPosition: Invalid \" + property + \" \\\"\" + value + \"\\\". \" +\n                \"Expected \\\"start\\\", \\\"end\\\" or \\\"center\\\".\");\n        }\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // TODO: refactor clipping detection into a separate thing (part of scrolling module)\n    // TODO: doesn't handle both flexible width and height when it has to scroll along both axis.\n    /** Class to be added to the overlay bounding box. */\n    var boundingBoxClass = 'cdk-overlay-connected-position-bounding-box';\n    /**\n     * A strategy for positioning overlays. Using this strategy, an overlay is given an\n     * implicit position relative some origin element. The relative position is defined in terms of\n     * a point on the origin element that is connected to a point on the overlay element. For example,\n     * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n     * of the overlay.\n     */\n    var FlexibleConnectedPositionStrategy = /** @class */ (function () {\n        function FlexibleConnectedPositionStrategy(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {\n            this._viewportRuler = _viewportRuler;\n            this._document = _document;\n            this._platform = _platform;\n            this._overlayContainer = _overlayContainer;\n            /** Last size used for the bounding box. Used to avoid resizing the overlay after open. */\n            this._lastBoundingBoxSize = { width: 0, height: 0 };\n            /** Whether the overlay was pushed in a previous positioning. */\n            this._isPushed = false;\n            /** Whether the overlay can be pushed on-screen on the initial open. */\n            this._canPush = true;\n            /** Whether the overlay can grow via flexible width/height after the initial open. */\n            this._growAfterOpen = false;\n            /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n            this._hasFlexibleDimensions = true;\n            /** Whether the overlay position is locked. */\n            this._positionLocked = false;\n            /** Amount of space that must be maintained between the overlay and the edge of the viewport. */\n            this._viewportMargin = 0;\n            /** The Scrollable containers used to check scrollable view properties on position change. */\n            this._scrollables = [];\n            /** Ordered list of preferred positions, from most to least desirable. */\n            this._preferredPositions = [];\n            /** Subject that emits whenever the position changes. */\n            this._positionChanges = new rxjs.Subject();\n            /** Subscription to viewport size changes. */\n            this._resizeSubscription = rxjs.Subscription.EMPTY;\n            /** Default offset for the overlay along the x axis. */\n            this._offsetX = 0;\n            /** Default offset for the overlay along the y axis. */\n            this._offsetY = 0;\n            /** Keeps track of the CSS classes that the position strategy has applied on the overlay panel. */\n            this._appliedPanelClasses = [];\n            /** Observable sequence of position changes. */\n            this.positionChanges = this._positionChanges.asObservable();\n            this.setOrigin(connectedTo);\n        }\n        Object.defineProperty(FlexibleConnectedPositionStrategy.prototype, \"positions\", {\n            /** Ordered list of preferred positions, from most to least desirable. */\n            get: function () {\n                return this._preferredPositions;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** Attaches this position strategy to an overlay. */\n        FlexibleConnectedPositionStrategy.prototype.attach = function (overlayRef) {\n            var _this = this;\n            if (this._overlayRef && overlayRef !== this._overlayRef) {\n                throw Error('This position strategy is already attached to an overlay');\n            }\n            this._validatePositions();\n            overlayRef.hostElement.classList.add(boundingBoxClass);\n            this._overlayRef = overlayRef;\n            this._boundingBox = overlayRef.hostElement;\n            this._pane = overlayRef.overlayElement;\n            this._isDisposed = false;\n            this._isInitialRender = true;\n            this._lastPosition = null;\n            this._resizeSubscription.unsubscribe();\n            this._resizeSubscription = this._viewportRuler.change().subscribe(function () {\n                // When the window is resized, we want to trigger the next reposition as if it\n                // was an initial render, in order for the strategy to pick a new optimal position,\n                // otherwise position locking will cause it to stay at the old one.\n                _this._isInitialRender = true;\n                _this.apply();\n            });\n        };\n        /**\n         * Updates the position of the overlay element, using whichever preferred position relative\n         * to the origin best fits on-screen.\n         *\n         * The selection of a position goes as follows:\n         *  - If any positions fit completely within the viewport as-is,\n         *      choose the first position that does so.\n         *  - If flexible dimensions are enabled and at least one satifies the given minimum width/height,\n         *      choose the position with the greatest available size modified by the positions' weight.\n         *  - If pushing is enabled, take the position that went off-screen the least and push it\n         *      on-screen.\n         *  - If none of the previous criteria were met, use the position that goes off-screen the least.\n         * @docs-private\n         */\n        FlexibleConnectedPositionStrategy.prototype.apply = function () {\n            var e_1, _a, e_2, _b;\n            // We shouldn't do anything if the strategy was disposed or we're on the server.\n            if (this._isDisposed || !this._platform.isBrowser) {\n                return;\n            }\n            // If the position has been applied already (e.g. when the overlay was opened) and the\n            // consumer opted into locking in the position, re-use the old position, in order to\n            // prevent the overlay from jumping around.\n            if (!this._isInitialRender && this._positionLocked && this._lastPosition) {\n                this.reapplyLastPosition();\n                return;\n            }\n            this._clearPanelClasses();\n            this._resetOverlayElementStyles();\n            this._resetBoundingBoxStyles();\n            // We need the bounding rects for the origin and the overlay to determine how to position\n            // the overlay relative to the origin.\n            // We use the viewport rect to determine whether a position would go off-screen.\n            this._viewportRect = this._getNarrowedViewportRect();\n            this._originRect = this._getOriginRect();\n            this._overlayRect = this._pane.getBoundingClientRect();\n            var originRect = this._originRect;\n            var overlayRect = this._overlayRect;\n            var viewportRect = this._viewportRect;\n            // Positions where the overlay will fit with flexible dimensions.\n            var flexibleFits = [];\n            // Fallback if none of the preferred positions fit within the viewport.\n            var fallback;\n            try {\n                // Go through each of the preferred positions looking for a good fit.\n                // If a good fit is found, it will be applied immediately.\n                for (var _c = tslib.__values(this._preferredPositions), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var pos = _d.value;\n                    // Get the exact (x, y) coordinate for the point-of-origin on the origin element.\n                    var originPoint = this._getOriginPoint(originRect, pos);\n                    // From that point-of-origin, get the exact (x, y) coordinate for the top-left corner of the\n                    // overlay in this position. We use the top-left corner for calculations and later translate\n                    // this into an appropriate (top, left, bottom, right) style.\n                    var overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);\n                    // Calculate how well the overlay would fit into the viewport with this point.\n                    var overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);\n                    // If the overlay, without any further work, fits into the viewport, use this position.\n                    if (overlayFit.isCompletelyWithinViewport) {\n                        this._isPushed = false;\n                        this._applyPosition(pos, originPoint);\n                        return;\n                    }\n                    // If the overlay has flexible dimensions, we can use this position\n                    // so long as there's enough space for the minimum dimensions.\n                    if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {\n                        // Save positions where the overlay will fit with flexible dimensions. We will use these\n                        // if none of the positions fit *without* flexible dimensions.\n                        flexibleFits.push({\n                            position: pos,\n                            origin: originPoint,\n                            overlayRect: overlayRect,\n                            boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)\n                        });\n                        continue;\n                    }\n                    // If the current preferred position does not fit on the screen, remember the position\n                    // if it has more visible area on-screen than we've seen and move onto the next preferred\n                    // position.\n                    if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {\n                        fallback = { overlayFit: overlayFit, overlayPoint: overlayPoint, originPoint: originPoint, position: pos, overlayRect: overlayRect };\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            // If there are any positions where the overlay would fit with flexible dimensions, choose the\n            // one that has the greatest area available modified by the position's weight\n            if (flexibleFits.length) {\n                var bestFit = null;\n                var bestScore = -1;\n                try {\n                    for (var flexibleFits_1 = tslib.__values(flexibleFits), flexibleFits_1_1 = flexibleFits_1.next(); !flexibleFits_1_1.done; flexibleFits_1_1 = flexibleFits_1.next()) {\n                        var fit = flexibleFits_1_1.value;\n                        var score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);\n                        if (score > bestScore) {\n                            bestScore = score;\n                            bestFit = fit;\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (flexibleFits_1_1 && !flexibleFits_1_1.done && (_b = flexibleFits_1.return)) _b.call(flexibleFits_1);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n                this._isPushed = false;\n                this._applyPosition(bestFit.position, bestFit.origin);\n                return;\n            }\n            // When none of the preferred positions fit within the viewport, take the position\n            // that went off-screen the least and attempt to push it on-screen.\n            if (this._canPush) {\n                // TODO(jelbourn): after pushing, the opening \"direction\" of the overlay might not make sense.\n                this._isPushed = true;\n                this._applyPosition(fallback.position, fallback.originPoint);\n                return;\n            }\n            // All options for getting the overlay within the viewport have been exhausted, so go with the\n            // position that went off-screen the least.\n            this._applyPosition(fallback.position, fallback.originPoint);\n        };\n        FlexibleConnectedPositionStrategy.prototype.detach = function () {\n            this._clearPanelClasses();\n            this._lastPosition = null;\n            this._previousPushAmount = null;\n            this._resizeSubscription.unsubscribe();\n        };\n        /** Cleanup after the element gets destroyed. */\n        FlexibleConnectedPositionStrategy.prototype.dispose = function () {\n            if (this._isDisposed) {\n                return;\n            }\n            // We can't use `_resetBoundingBoxStyles` here, because it resets\n            // some properties to zero, rather than removing them.\n            if (this._boundingBox) {\n                extendStyles(this._boundingBox.style, {\n                    top: '',\n                    left: '',\n                    right: '',\n                    bottom: '',\n                    height: '',\n                    width: '',\n                    alignItems: '',\n                    justifyContent: '',\n                });\n            }\n            if (this._pane) {\n                this._resetOverlayElementStyles();\n            }\n            if (this._overlayRef) {\n                this._overlayRef.hostElement.classList.remove(boundingBoxClass);\n            }\n            this.detach();\n            this._positionChanges.complete();\n            this._overlayRef = this._boundingBox = null;\n            this._isDisposed = true;\n        };\n        /**\n         * This re-aligns the overlay element with the trigger in its last calculated position,\n         * even if a position higher in the \"preferred positions\" list would now fit. This\n         * allows one to re-align the panel without changing the orientation of the panel.\n         */\n        FlexibleConnectedPositionStrategy.prototype.reapplyLastPosition = function () {\n            if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) {\n                this._originRect = this._getOriginRect();\n                this._overlayRect = this._pane.getBoundingClientRect();\n                this._viewportRect = this._getNarrowedViewportRect();\n                var lastPosition = this._lastPosition || this._preferredPositions[0];\n                var originPoint = this._getOriginPoint(this._originRect, lastPosition);\n                this._applyPosition(lastPosition, originPoint);\n            }\n        };\n        /**\n         * Sets the list of Scrollable containers that host the origin element so that\n         * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n         * Scrollable must be an ancestor element of the strategy's origin element.\n         */\n        FlexibleConnectedPositionStrategy.prototype.withScrollableContainers = function (scrollables) {\n            this._scrollables = scrollables;\n            return this;\n        };\n        /**\n         * Adds new preferred positions.\n         * @param positions List of positions options for this overlay.\n         */\n        FlexibleConnectedPositionStrategy.prototype.withPositions = function (positions) {\n            this._preferredPositions = positions;\n            // If the last calculated position object isn't part of the positions anymore, clear\n            // it in order to avoid it being picked up if the consumer tries to re-apply.\n            if (positions.indexOf(this._lastPosition) === -1) {\n                this._lastPosition = null;\n            }\n            this._validatePositions();\n            return this;\n        };\n        /**\n         * Sets a minimum distance the overlay may be positioned to the edge of the viewport.\n         * @param margin Required margin between the overlay and the viewport edge in pixels.\n         */\n        FlexibleConnectedPositionStrategy.prototype.withViewportMargin = function (margin) {\n            this._viewportMargin = margin;\n            return this;\n        };\n        /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */\n        FlexibleConnectedPositionStrategy.prototype.withFlexibleDimensions = function (flexibleDimensions) {\n            if (flexibleDimensions === void 0) { flexibleDimensions = true; }\n            this._hasFlexibleDimensions = flexibleDimensions;\n            return this;\n        };\n        /** Sets whether the overlay can grow after the initial open via flexible width/height. */\n        FlexibleConnectedPositionStrategy.prototype.withGrowAfterOpen = function (growAfterOpen) {\n            if (growAfterOpen === void 0) { growAfterOpen = true; }\n            this._growAfterOpen = growAfterOpen;\n            return this;\n        };\n        /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */\n        FlexibleConnectedPositionStrategy.prototype.withPush = function (canPush) {\n            if (canPush === void 0) { canPush = true; }\n            this._canPush = canPush;\n            return this;\n        };\n        /**\n         * Sets whether the overlay's position should be locked in after it is positioned\n         * initially. When an overlay is locked in, it won't attempt to reposition itself\n         * when the position is re-applied (e.g. when the user scrolls away).\n         * @param isLocked Whether the overlay should locked in.\n         */\n        FlexibleConnectedPositionStrategy.prototype.withLockedPosition = function (isLocked) {\n            if (isLocked === void 0) { isLocked = true; }\n            this._positionLocked = isLocked;\n            return this;\n        };\n        /**\n         * Sets the origin, relative to which to position the overlay.\n         * Using an element origin is useful for building components that need to be positioned\n         * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be\n         * used for cases like contextual menus which open relative to the user's pointer.\n         * @param origin Reference to the new origin.\n         */\n        FlexibleConnectedPositionStrategy.prototype.setOrigin = function (origin) {\n            this._origin = origin;\n            return this;\n        };\n        /**\n         * Sets the default offset for the overlay's connection point on the x-axis.\n         * @param offset New offset in the X axis.\n         */\n        FlexibleConnectedPositionStrategy.prototype.withDefaultOffsetX = function (offset) {\n            this._offsetX = offset;\n            return this;\n        };\n        /**\n         * Sets the default offset for the overlay's connection point on the y-axis.\n         * @param offset New offset in the Y axis.\n         */\n        FlexibleConnectedPositionStrategy.prototype.withDefaultOffsetY = function (offset) {\n            this._offsetY = offset;\n            return this;\n        };\n        /**\n         * Configures that the position strategy should set a `transform-origin` on some elements\n         * inside the overlay, depending on the current position that is being applied. This is\n         * useful for the cases where the origin of an animation can change depending on the\n         * alignment of the overlay.\n         * @param selector CSS selector that will be used to find the target\n         *    elements onto which to set the transform origin.\n         */\n        FlexibleConnectedPositionStrategy.prototype.withTransformOriginOn = function (selector) {\n            this._transformOriginSelector = selector;\n            return this;\n        };\n        /**\n         * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n         */\n        FlexibleConnectedPositionStrategy.prototype._getOriginPoint = function (originRect, pos) {\n            var x;\n            if (pos.originX == 'center') {\n                // Note: when centering we should always use the `left`\n                // offset, otherwise the position will be wrong in RTL.\n                x = originRect.left + (originRect.width / 2);\n            }\n            else {\n                var startX = this._isRtl() ? originRect.right : originRect.left;\n                var endX = this._isRtl() ? originRect.left : originRect.right;\n                x = pos.originX == 'start' ? startX : endX;\n            }\n            var y;\n            if (pos.originY == 'center') {\n                y = originRect.top + (originRect.height / 2);\n            }\n            else {\n                y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n            }\n            return { x: x, y: y };\n        };\n        /**\n         * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n         * origin point to which the overlay should be connected.\n         */\n        FlexibleConnectedPositionStrategy.prototype._getOverlayPoint = function (originPoint, overlayRect, pos) {\n            // Calculate the (overlayStartX, overlayStartY), the start of the\n            // potential overlay position relative to the origin point.\n            var overlayStartX;\n            if (pos.overlayX == 'center') {\n                overlayStartX = -overlayRect.width / 2;\n            }\n            else if (pos.overlayX === 'start') {\n                overlayStartX = this._isRtl() ? -overlayRect.width : 0;\n            }\n            else {\n                overlayStartX = this._isRtl() ? 0 : -overlayRect.width;\n            }\n            var overlayStartY;\n            if (pos.overlayY == 'center') {\n                overlayStartY = -overlayRect.height / 2;\n            }\n            else {\n                overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n            }\n            // The (x, y) coordinates of the overlay.\n            return {\n                x: originPoint.x + overlayStartX,\n                y: originPoint.y + overlayStartY,\n            };\n        };\n        /** Gets how well an overlay at the given point will fit within the viewport. */\n        FlexibleConnectedPositionStrategy.prototype._getOverlayFit = function (point, overlay, viewport, position) {\n            var x = point.x, y = point.y;\n            var offsetX = this._getOffset(position, 'x');\n            var offsetY = this._getOffset(position, 'y');\n            // Account for the offsets since they could push the overlay out of the viewport.\n            if (offsetX) {\n                x += offsetX;\n            }\n            if (offsetY) {\n                y += offsetY;\n            }\n            // How much the overlay would overflow at this position, on each side.\n            var leftOverflow = 0 - x;\n            var rightOverflow = (x + overlay.width) - viewport.width;\n            var topOverflow = 0 - y;\n            var bottomOverflow = (y + overlay.height) - viewport.height;\n            // Visible parts of the element on each axis.\n            var visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);\n            var visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);\n            var visibleArea = visibleWidth * visibleHeight;\n            return {\n                visibleArea: visibleArea,\n                isCompletelyWithinViewport: (overlay.width * overlay.height) === visibleArea,\n                fitsInViewportVertically: visibleHeight === overlay.height,\n                fitsInViewportHorizontally: visibleWidth == overlay.width,\n            };\n        };\n        /**\n         * Whether the overlay can fit within the viewport when it may resize either its width or height.\n         * @param fit How well the overlay fits in the viewport at some position.\n         * @param point The (x, y) coordinates of the overlat at some position.\n         * @param viewport The geometry of the viewport.\n         */\n        FlexibleConnectedPositionStrategy.prototype._canFitWithFlexibleDimensions = function (fit, point, viewport) {\n            if (this._hasFlexibleDimensions) {\n                var availableHeight = viewport.bottom - point.y;\n                var availableWidth = viewport.right - point.x;\n                var minHeight = this._overlayRef.getConfig().minHeight;\n                var minWidth = this._overlayRef.getConfig().minWidth;\n                var verticalFit = fit.fitsInViewportVertically ||\n                    (minHeight != null && minHeight <= availableHeight);\n                var horizontalFit = fit.fitsInViewportHorizontally ||\n                    (minWidth != null && minWidth <= availableWidth);\n                return verticalFit && horizontalFit;\n            }\n            return false;\n        };\n        /**\n         * Gets the point at which the overlay can be \"pushed\" on-screen. If the overlay is larger than\n         * the viewport, the top-left corner will be pushed on-screen (with overflow occuring on the\n         * right and bottom).\n         *\n         * @param start Starting point from which the overlay is pushed.\n         * @param overlay Dimensions of the overlay.\n         * @param scrollPosition Current viewport scroll position.\n         * @returns The point at which to position the overlay after pushing. This is effectively a new\n         *     originPoint.\n         */\n        FlexibleConnectedPositionStrategy.prototype._pushOverlayOnScreen = function (start, overlay, scrollPosition) {\n            // If the position is locked and we've pushed the overlay already, reuse the previous push\n            // amount, rather than pushing it again. If we were to continue pushing, the element would\n            // remain in the viewport, which goes against the expectations when position locking is enabled.\n            if (this._previousPushAmount && this._positionLocked) {\n                return {\n                    x: start.x + this._previousPushAmount.x,\n                    y: start.y + this._previousPushAmount.y\n                };\n            }\n            var viewport = this._viewportRect;\n            // Determine how much the overlay goes outside the viewport on each\n            // side, which we'll use to decide which direction to push it.\n            var overflowRight = Math.max(start.x + overlay.width - viewport.right, 0);\n            var overflowBottom = Math.max(start.y + overlay.height - viewport.bottom, 0);\n            var overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);\n            var overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);\n            // Amount by which to push the overlay in each axis such that it remains on-screen.\n            var pushX = 0;\n            var pushY = 0;\n            // If the overlay fits completely within the bounds of the viewport, push it from whichever\n            // direction is goes off-screen. Otherwise, push the top-left corner such that its in the\n            // viewport and allow for the trailing end of the overlay to go out of bounds.\n            if (overlay.width <= viewport.width) {\n                pushX = overflowLeft || -overflowRight;\n            }\n            else {\n                pushX = start.x < this._viewportMargin ? (viewport.left - scrollPosition.left) - start.x : 0;\n            }\n            if (overlay.height <= viewport.height) {\n                pushY = overflowTop || -overflowBottom;\n            }\n            else {\n                pushY = start.y < this._viewportMargin ? (viewport.top - scrollPosition.top) - start.y : 0;\n            }\n            this._previousPushAmount = { x: pushX, y: pushY };\n            return {\n                x: start.x + pushX,\n                y: start.y + pushY,\n            };\n        };\n        /**\n         * Applies a computed position to the overlay and emits a position change.\n         * @param position The position preference\n         * @param originPoint The point on the origin element where the overlay is connected.\n         */\n        FlexibleConnectedPositionStrategy.prototype._applyPosition = function (position, originPoint) {\n            this._setTransformOrigin(position);\n            this._setOverlayElementStyles(originPoint, position);\n            this._setBoundingBoxStyles(originPoint, position);\n            if (position.panelClass) {\n                this._addPanelClasses(position.panelClass);\n            }\n            // Save the last connected position in case the position needs to be re-calculated.\n            this._lastPosition = position;\n            // Notify that the position has been changed along with its change properties.\n            // We only emit if we've got any subscriptions, because the scroll visibility\n            // calculcations can be somewhat expensive.\n            if (this._positionChanges.observers.length) {\n                var scrollableViewProperties = this._getScrollVisibility();\n                var changeEvent = new ConnectedOverlayPositionChange(position, scrollableViewProperties);\n                this._positionChanges.next(changeEvent);\n            }\n            this._isInitialRender = false;\n        };\n        /** Sets the transform origin based on the configured selector and the passed-in position.  */\n        FlexibleConnectedPositionStrategy.prototype._setTransformOrigin = function (position) {\n            if (!this._transformOriginSelector) {\n                return;\n            }\n            var elements = this._boundingBox.querySelectorAll(this._transformOriginSelector);\n            var xOrigin;\n            var yOrigin = position.overlayY;\n            if (position.overlayX === 'center') {\n                xOrigin = 'center';\n            }\n            else if (this._isRtl()) {\n                xOrigin = position.overlayX === 'start' ? 'right' : 'left';\n            }\n            else {\n                xOrigin = position.overlayX === 'start' ? 'left' : 'right';\n            }\n            for (var i = 0; i < elements.length; i++) {\n                elements[i].style.transformOrigin = xOrigin + \" \" + yOrigin;\n            }\n        };\n        /**\n         * Gets the position and size of the overlay's sizing container.\n         *\n         * This method does no measuring and applies no styles so that we can cheaply compute the\n         * bounds for all positions and choose the best fit based on these results.\n         */\n        FlexibleConnectedPositionStrategy.prototype._calculateBoundingBoxRect = function (origin, position) {\n            var viewport = this._viewportRect;\n            var isRtl = this._isRtl();\n            var height, top, bottom;\n            if (position.overlayY === 'top') {\n                // Overlay is opening \"downward\" and thus is bound by the bottom viewport edge.\n                top = origin.y;\n                height = viewport.height - top + this._viewportMargin;\n            }\n            else if (position.overlayY === 'bottom') {\n                // Overlay is opening \"upward\" and thus is bound by the top viewport edge. We need to add\n                // the viewport margin back in, because the viewport rect is narrowed down to remove the\n                // margin, whereas the `origin` position is calculated based on its `ClientRect`.\n                bottom = viewport.height - origin.y + this._viewportMargin * 2;\n                height = viewport.height - bottom + this._viewportMargin;\n            }\n            else {\n                // If neither top nor bottom, it means that the overlay is vertically centered on the\n                // origin point. Note that we want the position relative to the viewport, rather than\n                // the page, which is why we don't use something like `viewport.bottom - origin.y` and\n                // `origin.y - viewport.top`.\n                var smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y);\n                var previousHeight = this._lastBoundingBoxSize.height;\n                height = smallestDistanceToViewportEdge * 2;\n                top = origin.y - smallestDistanceToViewportEdge;\n                if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {\n                    top = origin.y - (previousHeight / 2);\n                }\n            }\n            // The overlay is opening 'right-ward' (the content flows to the right).\n            var isBoundedByRightViewportEdge = (position.overlayX === 'start' && !isRtl) ||\n                (position.overlayX === 'end' && isRtl);\n            // The overlay is opening 'left-ward' (the content flows to the left).\n            var isBoundedByLeftViewportEdge = (position.overlayX === 'end' && !isRtl) ||\n                (position.overlayX === 'start' && isRtl);\n            var width, left, right;\n            if (isBoundedByLeftViewportEdge) {\n                right = viewport.width - origin.x + this._viewportMargin;\n                width = origin.x - this._viewportMargin;\n            }\n            else if (isBoundedByRightViewportEdge) {\n                left = origin.x;\n                width = viewport.right - origin.x;\n            }\n            else {\n                // If neither start nor end, it means that the overlay is horizontally centered on the\n                // origin point. Note that we want the position relative to the viewport, rather than\n                // the page, which is why we don't use something like `viewport.right - origin.x` and\n                // `origin.x - viewport.left`.\n                var smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x);\n                var previousWidth = this._lastBoundingBoxSize.width;\n                width = smallestDistanceToViewportEdge * 2;\n                left = origin.x - smallestDistanceToViewportEdge;\n                if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {\n                    left = origin.x - (previousWidth / 2);\n                }\n            }\n            return { top: top, left: left, bottom: bottom, right: right, width: width, height: height };\n        };\n        /**\n         * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the\n         * origin's connection point and stetches to the bounds of the viewport.\n         *\n         * @param origin The point on the origin element where the overlay is connected.\n         * @param position The position preference\n         */\n        FlexibleConnectedPositionStrategy.prototype._setBoundingBoxStyles = function (origin, position) {\n            var boundingBoxRect = this._calculateBoundingBoxRect(origin, position);\n            // It's weird if the overlay *grows* while scrolling, so we take the last size into account\n            // when applying a new size.\n            if (!this._isInitialRender && !this._growAfterOpen) {\n                boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);\n                boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);\n            }\n            var styles = {};\n            if (this._hasExactPosition()) {\n                styles.top = styles.left = '0';\n                styles.bottom = styles.right = styles.maxHeight = styles.maxWidth = '';\n                styles.width = styles.height = '100%';\n            }\n            else {\n                var maxHeight = this._overlayRef.getConfig().maxHeight;\n                var maxWidth = this._overlayRef.getConfig().maxWidth;\n                styles.height = coercion.coerceCssPixelValue(boundingBoxRect.height);\n                styles.top = coercion.coerceCssPixelValue(boundingBoxRect.top);\n                styles.bottom = coercion.coerceCssPixelValue(boundingBoxRect.bottom);\n                styles.width = coercion.coerceCssPixelValue(boundingBoxRect.width);\n                styles.left = coercion.coerceCssPixelValue(boundingBoxRect.left);\n                styles.right = coercion.coerceCssPixelValue(boundingBoxRect.right);\n                // Push the pane content towards the proper direction.\n                if (position.overlayX === 'center') {\n                    styles.alignItems = 'center';\n                }\n                else {\n                    styles.alignItems = position.overlayX === 'end' ? 'flex-end' : 'flex-start';\n                }\n                if (position.overlayY === 'center') {\n                    styles.justifyContent = 'center';\n                }\n                else {\n                    styles.justifyContent = position.overlayY === 'bottom' ? 'flex-end' : 'flex-start';\n                }\n                if (maxHeight) {\n                    styles.maxHeight = coercion.coerceCssPixelValue(maxHeight);\n                }\n                if (maxWidth) {\n                    styles.maxWidth = coercion.coerceCssPixelValue(maxWidth);\n                }\n            }\n            this._lastBoundingBoxSize = boundingBoxRect;\n            extendStyles(this._boundingBox.style, styles);\n        };\n        /** Resets the styles for the bounding box so that a new positioning can be computed. */\n        FlexibleConnectedPositionStrategy.prototype._resetBoundingBoxStyles = function () {\n            extendStyles(this._boundingBox.style, {\n                top: '0',\n                left: '0',\n                right: '0',\n                bottom: '0',\n                height: '',\n                width: '',\n                alignItems: '',\n                justifyContent: '',\n            });\n        };\n        /** Resets the styles for the overlay pane so that a new positioning can be computed. */\n        FlexibleConnectedPositionStrategy.prototype._resetOverlayElementStyles = function () {\n            extendStyles(this._pane.style, {\n                top: '',\n                left: '',\n                bottom: '',\n                right: '',\n                position: '',\n                transform: '',\n            });\n        };\n        /** Sets positioning styles to the overlay element. */\n        FlexibleConnectedPositionStrategy.prototype._setOverlayElementStyles = function (originPoint, position) {\n            var styles = {};\n            var hasExactPosition = this._hasExactPosition();\n            var hasFlexibleDimensions = this._hasFlexibleDimensions;\n            var config = this._overlayRef.getConfig();\n            if (hasExactPosition) {\n                var scrollPosition = this._viewportRuler.getViewportScrollPosition();\n                extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));\n                extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));\n            }\n            else {\n                styles.position = 'static';\n            }\n            // Use a transform to apply the offsets. We do this because the `center` positions rely on\n            // being in the normal flex flow and setting a `top` / `left` at all will completely throw\n            // off the position. We also can't use margins, because they won't have an effect in some\n            // cases where the element doesn't have anything to \"push off of\". Finally, this works\n            // better both with flexible and non-flexible positioning.\n            var transformString = '';\n            var offsetX = this._getOffset(position, 'x');\n            var offsetY = this._getOffset(position, 'y');\n            if (offsetX) {\n                transformString += \"translateX(\" + offsetX + \"px) \";\n            }\n            if (offsetY) {\n                transformString += \"translateY(\" + offsetY + \"px)\";\n            }\n            styles.transform = transformString.trim();\n            // If a maxWidth or maxHeight is specified on the overlay, we remove them. We do this because\n            // we need these values to both be set to \"100%\" for the automatic flexible sizing to work.\n            // The maxHeight and maxWidth are set on the boundingBox in order to enforce the constraint.\n            // Note that this doesn't apply when we have an exact position, in which case we do want to\n            // apply them because they'll be cleared from the bounding box.\n            if (config.maxHeight) {\n                if (hasExactPosition) {\n                    styles.maxHeight = coercion.coerceCssPixelValue(config.maxHeight);\n                }\n                else if (hasFlexibleDimensions) {\n                    styles.maxHeight = '';\n                }\n            }\n            if (config.maxWidth) {\n                if (hasExactPosition) {\n                    styles.maxWidth = coercion.coerceCssPixelValue(config.maxWidth);\n                }\n                else if (hasFlexibleDimensions) {\n                    styles.maxWidth = '';\n                }\n            }\n            extendStyles(this._pane.style, styles);\n        };\n        /** Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing. */\n        FlexibleConnectedPositionStrategy.prototype._getExactOverlayY = function (position, originPoint, scrollPosition) {\n            // Reset any existing styles. This is necessary in case the\n            // preferred position has changed since the last `apply`.\n            var styles = { top: null, bottom: null };\n            var overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n            if (this._isPushed) {\n                overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n            }\n            var virtualKeyboardOffset = this._overlayContainer.getContainerElement().getBoundingClientRect().top;\n            // Normally this would be zero, however when the overlay is attached to an input (e.g. in an\n            // autocomplete), mobile browsers will shift everything in order to put the input in the middle\n            // of the screen and to make space for the virtual keyboard. We need to account for this offset,\n            // otherwise our positioning will be thrown off.\n            overlayPoint.y -= virtualKeyboardOffset;\n            // We want to set either `top` or `bottom` based on whether the overlay wants to appear\n            // above or below the origin and the direction in which the element will expand.\n            if (position.overlayY === 'bottom') {\n                // When using `bottom`, we adjust the y position such that it is the distance\n                // from the bottom of the viewport rather than the top.\n                var documentHeight = this._document.documentElement.clientHeight;\n                styles.bottom = documentHeight - (overlayPoint.y + this._overlayRect.height) + \"px\";\n            }\n            else {\n                styles.top = coercion.coerceCssPixelValue(overlayPoint.y);\n            }\n            return styles;\n        };\n        /** Gets the exact left/right for the overlay when not using flexible sizing or when pushing. */\n        FlexibleConnectedPositionStrategy.prototype._getExactOverlayX = function (position, originPoint, scrollPosition) {\n            // Reset any existing styles. This is necessary in case the preferred position has\n            // changed since the last `apply`.\n            var styles = { left: null, right: null };\n            var overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n            if (this._isPushed) {\n                overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n            }\n            // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n            // or \"after\" the origin, which determines the direction in which the element will expand.\n            // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n            // page is in RTL or LTR.\n            var horizontalStyleProperty;\n            if (this._isRtl()) {\n                horizontalStyleProperty = position.overlayX === 'end' ? 'left' : 'right';\n            }\n            else {\n                horizontalStyleProperty = position.overlayX === 'end' ? 'right' : 'left';\n            }\n            // When we're setting `right`, we adjust the x position such that it is the distance\n            // from the right edge of the viewport rather than the left edge.\n            if (horizontalStyleProperty === 'right') {\n                var documentWidth = this._document.documentElement.clientWidth;\n                styles.right = documentWidth - (overlayPoint.x + this._overlayRect.width) + \"px\";\n            }\n            else {\n                styles.left = coercion.coerceCssPixelValue(overlayPoint.x);\n            }\n            return styles;\n        };\n        /**\n         * Gets the view properties of the trigger and overlay, including whether they are clipped\n         * or completely outside the view of any of the strategy's scrollables.\n         */\n        FlexibleConnectedPositionStrategy.prototype._getScrollVisibility = function () {\n            // Note: needs fresh rects since the position could've changed.\n            var originBounds = this._getOriginRect();\n            var overlayBounds = this._pane.getBoundingClientRect();\n            // TODO(jelbourn): instead of needing all of the client rects for these scrolling containers\n            // every time, we should be able to use the scrollTop of the containers if the size of those\n            // containers hasn't changed.\n            var scrollContainerBounds = this._scrollables.map(function (scrollable) {\n                return scrollable.getElementRef().nativeElement.getBoundingClientRect();\n            });\n            return {\n                isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n                isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n                isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n                isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n            };\n        };\n        /** Subtracts the amount that an element is overflowing on an axis from its length. */\n        FlexibleConnectedPositionStrategy.prototype._subtractOverflows = function (length) {\n            var overflows = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                overflows[_i - 1] = arguments[_i];\n            }\n            return overflows.reduce(function (currentValue, currentOverflow) {\n                return currentValue - Math.max(currentOverflow, 0);\n            }, length);\n        };\n        /** Narrows the given viewport rect by the current _viewportMargin. */\n        FlexibleConnectedPositionStrategy.prototype._getNarrowedViewportRect = function () {\n            // We recalculate the viewport rect here ourselves, rather than using the ViewportRuler,\n            // because we want to use the `clientWidth` and `clientHeight` as the base. The difference\n            // being that the client properties don't include the scrollbar, as opposed to `innerWidth`\n            // and `innerHeight` that do. This is necessary, because the overlay container uses\n            // 100% `width` and `height` which don't include the scrollbar either.\n            var width = this._document.documentElement.clientWidth;\n            var height = this._document.documentElement.clientHeight;\n            var scrollPosition = this._viewportRuler.getViewportScrollPosition();\n            return {\n                top: scrollPosition.top + this._viewportMargin,\n                left: scrollPosition.left + this._viewportMargin,\n                right: scrollPosition.left + width - this._viewportMargin,\n                bottom: scrollPosition.top + height - this._viewportMargin,\n                width: width - (2 * this._viewportMargin),\n                height: height - (2 * this._viewportMargin),\n            };\n        };\n        /** Whether the we're dealing with an RTL context */\n        FlexibleConnectedPositionStrategy.prototype._isRtl = function () {\n            return this._overlayRef.getDirection() === 'rtl';\n        };\n        /** Determines whether the overlay uses exact or flexible positioning. */\n        FlexibleConnectedPositionStrategy.prototype._hasExactPosition = function () {\n            return !this._hasFlexibleDimensions || this._isPushed;\n        };\n        /** Retrieves the offset of a position along the x or y axis. */\n        FlexibleConnectedPositionStrategy.prototype._getOffset = function (position, axis) {\n            if (axis === 'x') {\n                // We don't do something like `position['offset' + axis]` in\n                // order to avoid breking minifiers that rename properties.\n                return position.offsetX == null ? this._offsetX : position.offsetX;\n            }\n            return position.offsetY == null ? this._offsetY : position.offsetY;\n        };\n        /** Validates that the current position match the expected values. */\n        FlexibleConnectedPositionStrategy.prototype._validatePositions = function () {\n            if (!this._preferredPositions.length) {\n                throw Error('FlexibleConnectedPositionStrategy: At least one position is required.');\n            }\n            // TODO(crisbeto): remove these once Angular's template type\n            // checking is advanced enough to catch these cases.\n            this._preferredPositions.forEach(function (pair) {\n                validateHorizontalPosition('originX', pair.originX);\n                validateVerticalPosition('originY', pair.originY);\n                validateHorizontalPosition('overlayX', pair.overlayX);\n                validateVerticalPosition('overlayY', pair.overlayY);\n            });\n        };\n        /** Adds a single CSS class or an array of classes on the overlay panel. */\n        FlexibleConnectedPositionStrategy.prototype._addPanelClasses = function (cssClasses) {\n            var _this = this;\n            if (this._pane) {\n                coercion.coerceArray(cssClasses).forEach(function (cssClass) {\n                    if (cssClass !== '' && _this._appliedPanelClasses.indexOf(cssClass) === -1) {\n                        _this._appliedPanelClasses.push(cssClass);\n                        _this._pane.classList.add(cssClass);\n                    }\n                });\n            }\n        };\n        /** Clears the classes that the position strategy has applied from the overlay panel. */\n        FlexibleConnectedPositionStrategy.prototype._clearPanelClasses = function () {\n            var _this = this;\n            if (this._pane) {\n                this._appliedPanelClasses.forEach(function (cssClass) {\n                    _this._pane.classList.remove(cssClass);\n                });\n                this._appliedPanelClasses = [];\n            }\n        };\n        /** Returns the ClientRect of the current origin. */\n        FlexibleConnectedPositionStrategy.prototype._getOriginRect = function () {\n            var origin = this._origin;\n            if (origin instanceof i0.ElementRef) {\n                return origin.nativeElement.getBoundingClientRect();\n            }\n            if (origin instanceof HTMLElement) {\n                return origin.getBoundingClientRect();\n            }\n            var width = origin.width || 0;\n            var height = origin.height || 0;\n            // If the origin is a point, return a client rect as if it was a 0x0 element at the point.\n            return {\n                top: origin.y,\n                bottom: origin.y + height,\n                left: origin.x,\n                right: origin.x + width,\n                height: height,\n                width: width\n            };\n        };\n        return FlexibleConnectedPositionStrategy;\n    }());\n    /** Shallow-extends a stylesheet object with another stylesheet object. */\n    function extendStyles(dest, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                dest[key] = source[key];\n            }\n        }\n        return dest;\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * A strategy for positioning overlays. Using this strategy, an overlay is given an\n     * implicit position relative to some origin element. The relative position is defined in terms of\n     * a point on the origin element that is connected to a point on the overlay element. For example,\n     * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n     * of the overlay.\n     * @deprecated Use `FlexibleConnectedPositionStrategy` instead.\n     * @breaking-change 8.0.0\n     */\n    var ConnectedPositionStrategy = /** @class */ (function () {\n        function ConnectedPositionStrategy(originPos, overlayPos, connectedTo, viewportRuler, document, platform, overlayContainer) {\n            /** Ordered list of preferred positions, from most to least desirable. */\n            this._preferredPositions = [];\n            // Since the `ConnectedPositionStrategy` is deprecated and we don't want to maintain\n            // the extra logic, we create an instance of the positioning strategy that has some\n            // defaults that make it behave as the old position strategy and to which we'll\n            // proxy all of the API calls.\n            this._positionStrategy = new FlexibleConnectedPositionStrategy(connectedTo, viewportRuler, document, platform, overlayContainer)\n                .withFlexibleDimensions(false)\n                .withPush(false)\n                .withViewportMargin(0);\n            this.withFallbackPosition(originPos, overlayPos);\n        }\n        Object.defineProperty(ConnectedPositionStrategy.prototype, \"_isRtl\", {\n            /** Whether the we're dealing with an RTL context */\n            get: function () {\n                return this._overlayRef.getDirection() === 'rtl';\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ConnectedPositionStrategy.prototype, \"onPositionChange\", {\n            /** Emits an event when the connection point changes. */\n            get: function () {\n                return this._positionStrategy.positionChanges;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ConnectedPositionStrategy.prototype, \"positions\", {\n            /** Ordered list of preferred positions, from most to least desirable. */\n            get: function () {\n                return this._preferredPositions;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** Attach this position strategy to an overlay. */\n        ConnectedPositionStrategy.prototype.attach = function (overlayRef) {\n            this._overlayRef = overlayRef;\n            this._positionStrategy.attach(overlayRef);\n            if (this._direction) {\n                overlayRef.setDirection(this._direction);\n                this._direction = null;\n            }\n        };\n        /** Disposes all resources used by the position strategy. */\n        ConnectedPositionStrategy.prototype.dispose = function () {\n            this._positionStrategy.dispose();\n        };\n        /** @docs-private */\n        ConnectedPositionStrategy.prototype.detach = function () {\n            this._positionStrategy.detach();\n        };\n        /**\n         * Updates the position of the overlay element, using whichever preferred position relative\n         * to the origin fits on-screen.\n         * @docs-private\n         */\n        ConnectedPositionStrategy.prototype.apply = function () {\n            this._positionStrategy.apply();\n        };\n        /**\n         * Re-positions the overlay element with the trigger in its last calculated position,\n         * even if a position higher in the \"preferred positions\" list would now fit. This\n         * allows one to re-align the panel without changing the orientation of the panel.\n         */\n        ConnectedPositionStrategy.prototype.recalculateLastPosition = function () {\n            this._positionStrategy.reapplyLastPosition();\n        };\n        /**\n         * Sets the list of Scrollable containers that host the origin element so that\n         * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n         * Scrollable must be an ancestor element of the strategy's origin element.\n         */\n        ConnectedPositionStrategy.prototype.withScrollableContainers = function (scrollables) {\n            this._positionStrategy.withScrollableContainers(scrollables);\n        };\n        /**\n         * Adds a new preferred fallback position.\n         * @param originPos\n         * @param overlayPos\n         */\n        ConnectedPositionStrategy.prototype.withFallbackPosition = function (originPos, overlayPos, offsetX, offsetY) {\n            var position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);\n            this._preferredPositions.push(position);\n            this._positionStrategy.withPositions(this._preferredPositions);\n            return this;\n        };\n        /**\n         * Sets the layout direction so the overlay's position can be adjusted to match.\n         * @param dir New layout direction.\n         */\n        ConnectedPositionStrategy.prototype.withDirection = function (dir) {\n            // Since the direction might be declared before the strategy is attached,\n            // we save the value in a temporary property and we'll transfer it to the\n            // overlay ref on attachment.\n            if (this._overlayRef) {\n                this._overlayRef.setDirection(dir);\n            }\n            else {\n                this._direction = dir;\n            }\n            return this;\n        };\n        /**\n         * Sets an offset for the overlay's connection point on the x-axis\n         * @param offset New offset in the X axis.\n         */\n        ConnectedPositionStrategy.prototype.withOffsetX = function (offset) {\n            this._positionStrategy.withDefaultOffsetX(offset);\n            return this;\n        };\n        /**\n         * Sets an offset for the overlay's connection point on the y-axis\n         * @param  offset New offset in the Y axis.\n         */\n        ConnectedPositionStrategy.prototype.withOffsetY = function (offset) {\n            this._positionStrategy.withDefaultOffsetY(offset);\n            return this;\n        };\n        /**\n         * Sets whether the overlay's position should be locked in after it is positioned\n         * initially. When an overlay is locked in, it won't attempt to reposition itself\n         * when the position is re-applied (e.g. when the user scrolls away).\n         * @param isLocked Whether the overlay should locked in.\n         */\n        ConnectedPositionStrategy.prototype.withLockedPosition = function (isLocked) {\n            this._positionStrategy.withLockedPosition(isLocked);\n            return this;\n        };\n        /**\n         * Overwrites the current set of positions with an array of new ones.\n         * @param positions Position pairs to be set on the strategy.\n         */\n        ConnectedPositionStrategy.prototype.withPositions = function (positions) {\n            this._preferredPositions = positions.slice();\n            this._positionStrategy.withPositions(this._preferredPositions);\n            return this;\n        };\n        /**\n         * Sets the origin element, relative to which to position the overlay.\n         * @param origin Reference to the new origin element.\n         */\n        ConnectedPositionStrategy.prototype.setOrigin = function (origin) {\n            this._positionStrategy.setOrigin(origin);\n            return this;\n        };\n        return ConnectedPositionStrategy;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Class to be added to the overlay pane wrapper. */\n    var wrapperClass = 'cdk-global-overlay-wrapper';\n    /**\n     * A strategy for positioning overlays. Using this strategy, an overlay is given an\n     * explicit position relative to the browser's viewport. We use flexbox, instead of\n     * transforms, in order to avoid issues with subpixel rendering which can cause the\n     * element to become blurry.\n     */\n    var GlobalPositionStrategy = /** @class */ (function () {\n        function GlobalPositionStrategy() {\n            this._cssPosition = 'static';\n            this._topOffset = '';\n            this._bottomOffset = '';\n            this._leftOffset = '';\n            this._rightOffset = '';\n            this._alignItems = '';\n            this._justifyContent = '';\n            this._width = '';\n            this._height = '';\n        }\n        GlobalPositionStrategy.prototype.attach = function (overlayRef) {\n            var config = overlayRef.getConfig();\n            this._overlayRef = overlayRef;\n            if (this._width && !config.width) {\n                overlayRef.updateSize({ width: this._width });\n            }\n            if (this._height && !config.height) {\n                overlayRef.updateSize({ height: this._height });\n            }\n            overlayRef.hostElement.classList.add(wrapperClass);\n            this._isDisposed = false;\n        };\n        /**\n         * Sets the top position of the overlay. Clears any previously set vertical position.\n         * @param value New top offset.\n         */\n        GlobalPositionStrategy.prototype.top = function (value) {\n            if (value === void 0) { value = ''; }\n            this._bottomOffset = '';\n            this._topOffset = value;\n            this._alignItems = 'flex-start';\n            return this;\n        };\n        /**\n         * Sets the left position of the overlay. Clears any previously set horizontal position.\n         * @param value New left offset.\n         */\n        GlobalPositionStrategy.prototype.left = function (value) {\n            if (value === void 0) { value = ''; }\n            this._rightOffset = '';\n            this._leftOffset = value;\n            this._justifyContent = 'flex-start';\n            return this;\n        };\n        /**\n         * Sets the bottom position of the overlay. Clears any previously set vertical position.\n         * @param value New bottom offset.\n         */\n        GlobalPositionStrategy.prototype.bottom = function (value) {\n            if (value === void 0) { value = ''; }\n            this._topOffset = '';\n            this._bottomOffset = value;\n            this._alignItems = 'flex-end';\n            return this;\n        };\n        /**\n         * Sets the right position of the overlay. Clears any previously set horizontal position.\n         * @param value New right offset.\n         */\n        GlobalPositionStrategy.prototype.right = function (value) {\n            if (value === void 0) { value = ''; }\n            this._leftOffset = '';\n            this._rightOffset = value;\n            this._justifyContent = 'flex-end';\n            return this;\n        };\n        /**\n         * Sets the overlay width and clears any previously set width.\n         * @param value New width for the overlay\n         * @deprecated Pass the `width` through the `OverlayConfig`.\n         * @breaking-change 8.0.0\n         */\n        GlobalPositionStrategy.prototype.width = function (value) {\n            if (value === void 0) { value = ''; }\n            if (this._overlayRef) {\n                this._overlayRef.updateSize({ width: value });\n            }\n            else {\n                this._width = value;\n            }\n            return this;\n        };\n        /**\n         * Sets the overlay height and clears any previously set height.\n         * @param value New height for the overlay\n         * @deprecated Pass the `height` through the `OverlayConfig`.\n         * @breaking-change 8.0.0\n         */\n        GlobalPositionStrategy.prototype.height = function (value) {\n            if (value === void 0) { value = ''; }\n            if (this._overlayRef) {\n                this._overlayRef.updateSize({ height: value });\n            }\n            else {\n                this._height = value;\n            }\n            return this;\n        };\n        /**\n         * Centers the overlay horizontally with an optional offset.\n         * Clears any previously set horizontal position.\n         *\n         * @param offset Overlay offset from the horizontal center.\n         */\n        GlobalPositionStrategy.prototype.centerHorizontally = function (offset) {\n            if (offset === void 0) { offset = ''; }\n            this.left(offset);\n            this._justifyContent = 'center';\n            return this;\n        };\n        /**\n         * Centers the overlay vertically with an optional offset.\n         * Clears any previously set vertical position.\n         *\n         * @param offset Overlay offset from the vertical center.\n         */\n        GlobalPositionStrategy.prototype.centerVertically = function (offset) {\n            if (offset === void 0) { offset = ''; }\n            this.top(offset);\n            this._alignItems = 'center';\n            return this;\n        };\n        /**\n         * Apply the position to the element.\n         * @docs-private\n         */\n        GlobalPositionStrategy.prototype.apply = function () {\n            // Since the overlay ref applies the strategy asynchronously, it could\n            // have been disposed before it ends up being applied. If that is the\n            // case, we shouldn't do anything.\n            if (!this._overlayRef || !this._overlayRef.hasAttached()) {\n                return;\n            }\n            var styles = this._overlayRef.overlayElement.style;\n            var parentStyles = this._overlayRef.hostElement.style;\n            var config = this._overlayRef.getConfig();\n            styles.position = this._cssPosition;\n            styles.marginLeft = config.width === '100%' ? '0' : this._leftOffset;\n            styles.marginTop = config.height === '100%' ? '0' : this._topOffset;\n            styles.marginBottom = this._bottomOffset;\n            styles.marginRight = this._rightOffset;\n            if (config.width === '100%') {\n                parentStyles.justifyContent = 'flex-start';\n            }\n            else if (this._justifyContent === 'center') {\n                parentStyles.justifyContent = 'center';\n            }\n            else if (this._overlayRef.getConfig().direction === 'rtl') {\n                // In RTL the browser will invert `flex-start` and `flex-end` automatically, but we\n                // don't want that because our positioning is explicitly `left` and `right`, hence\n                // why we do another inversion to ensure that the overlay stays in the same position.\n                // TODO: reconsider this if we add `start` and `end` methods.\n                if (this._justifyContent === 'flex-start') {\n                    parentStyles.justifyContent = 'flex-end';\n                }\n                else if (this._justifyContent === 'flex-end') {\n                    parentStyles.justifyContent = 'flex-start';\n                }\n            }\n            else {\n                parentStyles.justifyContent = this._justifyContent;\n            }\n            parentStyles.alignItems = config.height === '100%' ? 'flex-start' : this._alignItems;\n        };\n        /**\n         * Cleans up the DOM changes from the position strategy.\n         * @docs-private\n         */\n        GlobalPositionStrategy.prototype.dispose = function () {\n            if (this._isDisposed || !this._overlayRef) {\n                return;\n            }\n            var styles = this._overlayRef.overlayElement.style;\n            var parent = this._overlayRef.hostElement;\n            var parentStyles = parent.style;\n            parent.classList.remove(wrapperClass);\n            parentStyles.justifyContent = parentStyles.alignItems = styles.marginTop =\n                styles.marginBottom = styles.marginLeft = styles.marginRight = styles.position = '';\n            this._overlayRef = null;\n            this._isDisposed = true;\n        };\n        return GlobalPositionStrategy;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Builder for overlay position strategy. */\n    var OverlayPositionBuilder = /** @class */ (function () {\n        function OverlayPositionBuilder(_viewportRuler, _document, _platform, _overlayContainer) {\n            this._viewportRuler = _viewportRuler;\n            this._document = _document;\n            this._platform = _platform;\n            this._overlayContainer = _overlayContainer;\n        }\n        /**\n         * Creates a global position strategy.\n         */\n        OverlayPositionBuilder.prototype.global = function () {\n            return new GlobalPositionStrategy();\n        };\n        /**\n         * Creates a relative position strategy.\n         * @param elementRef\n         * @param originPos\n         * @param overlayPos\n         * @deprecated Use `flexibleConnectedTo` instead.\n         * @breaking-change 8.0.0\n         */\n        OverlayPositionBuilder.prototype.connectedTo = function (elementRef, originPos, overlayPos) {\n            return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document, this._platform, this._overlayContainer);\n        };\n        /**\n         * Creates a flexible position strategy.\n         * @param origin Origin relative to which to position the overlay.\n         */\n        OverlayPositionBuilder.prototype.flexibleConnectedTo = function (origin) {\n            return new FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);\n        };\n        OverlayPositionBuilder.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        OverlayPositionBuilder.ctorParameters = function () { return [\n            { type: scrolling.ViewportRuler },\n            { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] },\n            { type: platform.Platform },\n            { type: OverlayContainer }\n        ]; };\n        OverlayPositionBuilder.ɵprov = i0.ɵɵdefineInjectable({ factory: function OverlayPositionBuilder_Factory() { return new OverlayPositionBuilder(i0.ɵɵinject(ViewportRuler), i0.ɵɵinject(i1.DOCUMENT), i0.ɵɵinject(Platform), i0.ɵɵinject(OverlayContainer)); }, token: OverlayPositionBuilder, providedIn: \"root\" });\n        return OverlayPositionBuilder;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Next overlay unique ID. */\n    var nextUniqueId = 0;\n    // Note that Overlay is *not* scoped to the app root because of the ComponentFactoryResolver\n    // which needs to be different depending on where OverlayModule is imported.\n    /**\n     * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n     * used as a low-level building block for other components. Dialogs, tooltips, menus,\n     * selects, etc. can all be built using overlays. The service should primarily be used by authors\n     * of re-usable components rather than developers building end-user applications.\n     *\n     * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n     */\n    var Overlay = /** @class */ (function () {\n        function Overlay(\n        /** Scrolling strategies that can be used when creating an overlay. */\n        scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _injector, _ngZone, _document, _directionality, \n        // @breaking-change 8.0.0 `_location` parameter to be made required.\n        _location) {\n            this.scrollStrategies = scrollStrategies;\n            this._overlayContainer = _overlayContainer;\n            this._componentFactoryResolver = _componentFactoryResolver;\n            this._positionBuilder = _positionBuilder;\n            this._keyboardDispatcher = _keyboardDispatcher;\n            this._injector = _injector;\n            this._ngZone = _ngZone;\n            this._document = _document;\n            this._directionality = _directionality;\n            this._location = _location;\n        }\n        /**\n         * Creates an overlay.\n         * @param config Configuration applied to the overlay.\n         * @returns Reference to the created overlay.\n         */\n        Overlay.prototype.create = function (config) {\n            var host = this._createHostElement();\n            var pane = this._createPaneElement(host);\n            var portalOutlet = this._createPortalOutlet(pane);\n            var overlayConfig = new OverlayConfig(config);\n            overlayConfig.direction = overlayConfig.direction || this._directionality.value;\n            return new OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._keyboardDispatcher, this._document, this._location);\n        };\n        /**\n         * Gets a position builder that can be used, via fluent API,\n         * to construct and configure a position strategy.\n         * @returns An overlay position builder.\n         */\n        Overlay.prototype.position = function () {\n            return this._positionBuilder;\n        };\n        /**\n         * Creates the DOM element for an overlay and appends it to the overlay container.\n         * @returns Newly-created pane element\n         */\n        Overlay.prototype._createPaneElement = function (host) {\n            var pane = this._document.createElement('div');\n            pane.id = \"cdk-overlay-\" + nextUniqueId++;\n            pane.classList.add('cdk-overlay-pane');\n            host.appendChild(pane);\n            return pane;\n        };\n        /**\n         * Creates the host element that wraps around an overlay\n         * and can be used for advanced positioning.\n         * @returns Newly-create host element.\n         */\n        Overlay.prototype._createHostElement = function () {\n            var host = this._document.createElement('div');\n            this._overlayContainer.getContainerElement().appendChild(host);\n            return host;\n        };\n        /**\n         * Create a DomPortalOutlet into which the overlay content can be loaded.\n         * @param pane The DOM element to turn into a portal outlet.\n         * @returns A portal outlet for the given DOM element.\n         */\n        Overlay.prototype._createPortalOutlet = function (pane) {\n            // We have to resolve the ApplicationRef later in order to allow people\n            // to use overlay-based providers during app initialization.\n            if (!this._appRef) {\n                this._appRef = this._injector.get(i0.ApplicationRef);\n            }\n            return new portal.DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector, this._document);\n        };\n        Overlay.decorators = [\n            { type: i0.Injectable }\n        ];\n        /** @nocollapse */\n        Overlay.ctorParameters = function () { return [\n            { type: ScrollStrategyOptions },\n            { type: OverlayContainer },\n            { type: i0.ComponentFactoryResolver },\n            { type: OverlayPositionBuilder },\n            { type: OverlayKeyboardDispatcher },\n            { type: i0.Injector },\n            { type: i0.NgZone },\n            { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] },\n            { type: bidi.Directionality },\n            { type: i1.Location, decorators: [{ type: i0.Optional }] }\n        ]; };\n        return Overlay;\n    }());\n\n    /** Injection token that can be used to specify default bottom sheet options. */\n    var MAT_BOTTOM_SHEET_DEFAULT_OPTIONS = new i0.InjectionToken('mat-bottom-sheet-default-options');\n    /**\n     * Service to trigger Material Design bottom sheets.\n     */\n    var MatBottomSheet = /** @class */ (function () {\n        function MatBottomSheet(_overlay, _injector, _parentBottomSheet, _location, _defaultOptions) {\n            this._overlay = _overlay;\n            this._injector = _injector;\n            this._parentBottomSheet = _parentBottomSheet;\n            this._location = _location;\n            this._defaultOptions = _defaultOptions;\n            this._bottomSheetRefAtThisLevel = null;\n        }\n        Object.defineProperty(MatBottomSheet.prototype, \"_openedBottomSheetRef\", {\n            /** Reference to the currently opened bottom sheet. */\n            get: function () {\n                var parent = this._parentBottomSheet;\n                return parent ? parent._openedBottomSheetRef : this._bottomSheetRefAtThisLevel;\n            },\n            set: function (value) {\n                if (this._parentBottomSheet) {\n                    this._parentBottomSheet._openedBottomSheetRef = value;\n                }\n                else {\n                    this._bottomSheetRefAtThisLevel = value;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MatBottomSheet.prototype.open = function (componentOrTemplateRef, config) {\n            var _this = this;\n            var _config = _applyConfigDefaults(this._defaultOptions || new MatBottomSheetConfig(), config);\n            var overlayRef = this._createOverlay(_config);\n            var container = this._attachContainer(overlayRef, _config);\n            var ref = new MatBottomSheetRef(container, overlayRef, this._location);\n            if (componentOrTemplateRef instanceof i0.TemplateRef) {\n                container.attachTemplatePortal(new portal.TemplatePortal(componentOrTemplateRef, null, {\n                    $implicit: _config.data,\n                    bottomSheetRef: ref\n                }));\n            }\n            else {\n                var portal$1 = new portal.ComponentPortal(componentOrTemplateRef, undefined, this._createInjector(_config, ref));\n                var contentRef = container.attachComponentPortal(portal$1);\n                ref.instance = contentRef.instance;\n            }\n            // When the bottom sheet is dismissed, clear the reference to it.\n            ref.afterDismissed().subscribe(function () {\n                // Clear the bottom sheet ref if it hasn't already been replaced by a newer one.\n                if (_this._openedBottomSheetRef == ref) {\n                    _this._openedBottomSheetRef = null;\n                }\n            });\n            if (this._openedBottomSheetRef) {\n                // If a bottom sheet is already in view, dismiss it and enter the\n                // new bottom sheet after exit animation is complete.\n                this._openedBottomSheetRef.afterDismissed().subscribe(function () { return ref.containerInstance.enter(); });\n                this._openedBottomSheetRef.dismiss();\n            }\n            else {\n                // If no bottom sheet is in view, enter the new bottom sheet.\n                ref.containerInstance.enter();\n            }\n            this._openedBottomSheetRef = ref;\n            return ref;\n        };\n        /**\n         * Dismisses the currently-visible bottom sheet.\n         */\n        MatBottomSheet.prototype.dismiss = function () {\n            if (this._openedBottomSheetRef) {\n                this._openedBottomSheetRef.dismiss();\n            }\n        };\n        MatBottomSheet.prototype.ngOnDestroy = function () {\n            if (this._bottomSheetRefAtThisLevel) {\n                this._bottomSheetRefAtThisLevel.dismiss();\n            }\n        };\n        /**\n         * Attaches the bottom sheet container component to the overlay.\n         */\n        MatBottomSheet.prototype._attachContainer = function (overlayRef, config) {\n            var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\n            var injector = new portal.PortalInjector(userInjector || this._injector, new WeakMap([\n                [MatBottomSheetConfig, config]\n            ]));\n            var containerPortal = new portal.ComponentPortal(MatBottomSheetContainer, config.viewContainerRef, injector);\n            var containerRef = overlayRef.attach(containerPortal);\n            return containerRef.instance;\n        };\n        /**\n         * Creates a new overlay and places it in the correct location.\n         * @param config The user-specified bottom sheet config.\n         */\n        MatBottomSheet.prototype._createOverlay = function (config) {\n            var overlayConfig = new overlay.OverlayConfig({\n                direction: config.direction,\n                hasBackdrop: config.hasBackdrop,\n                disposeOnNavigation: config.closeOnNavigation,\n                maxWidth: '100%',\n                scrollStrategy: config.scrollStrategy || this._overlay.scrollStrategies.block(),\n                positionStrategy: this._overlay.position().global().centerHorizontally().bottom('0')\n            });\n            if (config.backdropClass) {\n                overlayConfig.backdropClass = config.backdropClass;\n            }\n            return this._overlay.create(overlayConfig);\n        };\n        /**\n         * Creates an injector to be used inside of a bottom sheet component.\n         * @param config Config that was used to create the bottom sheet.\n         * @param bottomSheetRef Reference to the bottom sheet.\n         */\n        MatBottomSheet.prototype._createInjector = function (config, bottomSheetRef) {\n            var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\n            var injectionTokens = new WeakMap([\n                [MatBottomSheetRef, bottomSheetRef],\n                [MAT_BOTTOM_SHEET_DATA, config.data]\n            ]);\n            if (config.direction &&\n                (!userInjector || !userInjector.get(bidi.Directionality, null))) {\n                injectionTokens.set(bidi.Directionality, {\n                    value: config.direction,\n                    change: rxjs.of()\n                });\n            }\n            return new portal.PortalInjector(userInjector || this._injector, injectionTokens);\n        };\n        MatBottomSheet.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: MatBottomSheetModule },] }\n        ];\n        /** @nocollapse */\n        MatBottomSheet.ctorParameters = function () { return [\n            { type: overlay.Overlay },\n            { type: i0.Injector },\n            { type: MatBottomSheet, decorators: [{ type: i0.Optional }, { type: i0.SkipSelf }] },\n            { type: i1.Location, decorators: [{ type: i0.Optional }] },\n            { type: MatBottomSheetConfig, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [MAT_BOTTOM_SHEET_DEFAULT_OPTIONS,] }] }\n        ]; };\n        MatBottomSheet.ɵprov = i0.ɵɵdefineInjectable({ factory: function MatBottomSheet_Factory() { return new MatBottomSheet(i0.ɵɵinject(Overlay), i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(MatBottomSheet, 12), i0.ɵɵinject(i1.Location, 8), i0.ɵɵinject(MAT_BOTTOM_SHEET_DEFAULT_OPTIONS, 8)); }, token: MatBottomSheet, providedIn: MatBottomSheetModule });\n        return MatBottomSheet;\n    }());\n    /**\n     * Applies default options to the bottom sheet config.\n     * @param defaults Object containing the default values to which to fall back.\n     * @param config The configuration to which the defaults will be applied.\n     * @returns The new configuration object with defaults applied.\n     */\n    function _applyConfigDefaults(defaults, config) {\n        return tslib.__assign(tslib.__assign({}, defaults), config);\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.MAT_BOTTOM_SHEET_DATA = MAT_BOTTOM_SHEET_DATA;\n    exports.MAT_BOTTOM_SHEET_DEFAULT_OPTIONS = MAT_BOTTOM_SHEET_DEFAULT_OPTIONS;\n    exports.MatBottomSheet = MatBottomSheet;\n    exports.MatBottomSheetConfig = MatBottomSheetConfig;\n    exports.MatBottomSheetContainer = MatBottomSheetContainer;\n    exports.MatBottomSheetModule = MatBottomSheetModule;\n    exports.MatBottomSheetRef = MatBottomSheetRef;\n    exports.matBottomSheetAnimations = matBottomSheetAnimations;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=material-bottom-sheet.umd.js.map\n"]}