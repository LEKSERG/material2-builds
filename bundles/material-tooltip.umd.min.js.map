{"version":3,"sources":["src/material/material-tooltip.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","material","tooltip","cdk","overlay","a11y","common","core","platformBrowser","tslib","bidi","coercion","keycodes","layout","platform","portal","scrolling","rxjs","operators","animations","this","core$1","tslib_1","matTooltipAnimations","tooltipState","trigger","state","style","opacity","transform","transition","animate","keyframes","offset","SCROLL_THROTTLE_MS","getMatTooltipInvalidPositionError","position","Error","MAT_TOOLTIP_SCROLL_STRATEGY","InjectionToken","MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY","scrollStrategies","reposition","scrollThrottle","MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER","provide","deps","Overlay","useFactory","MAT_TOOLTIP_DEFAULT_OPTIONS","providedIn","MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY","showDelay","hideDelay","touchendHideDelay","MatTooltip","_overlay","_elementRef","_scrollDispatcher","_viewContainerRef","_ngZone","_ariaDescriber","_focusMonitor","scrollStrategy","_dir","_defaultOptions","hammerLoader","_this","_position","_disabled","_message","_manualListeners","Map","_destroyed","Subject","_scrollStrategy","element","nativeElement","hasGestures","window","Hammer","IOS","ANDROID","set","show","hide","forEach","listener","event","addEventListener","monitor","pipe","takeUntil","subscribe","origin","run","Object","defineProperty","prototype","get","value","_overlayRef","_updatePosition","_tooltipInstance","updatePosition","enumerable","configurable","coerceBooleanProperty","removeDescription","trim","_isTooltipVisible","_updateTooltipMessage","runOutsideAngular","Promise","resolve","then","describe","message","_tooltipClass","_setTooltipClass","ngOnInit","elementStyle","nodeName","webkitUserSelect","userSelect","msUserSelect","draggable","webkitUserDrag","ngOnDestroy","dispose","removeEventListener","clear","next","complete","stopMonitoring","delay","disabled","_showTimeoutId","_hideTimeoutId","overlayRef","_createOverlay","_detach","_portal","ComponentPortal","TooltipComponent","attach","instance","afterHidden","toggle","isVisible","_handleKeydown","e","keyCode","ESCAPE","hasModifierKey","preventDefault","stopPropagation","_handleTouchend","scrollableAncestors","getAncestorScrollContainers","strategy","flexibleConnectedTo","withTransformOriginOn","withFlexibleDimensions","withViewportMargin","withScrollableContainers","positionChanges","change","scrollableViewProperties","isOverlayClipped","create","direction","positionStrategy","panelClass","detachments","hasAttached","detach","getConfig","_getOrigin","_getOverlayPosition","withPositions","__assign","main","fallback","originPosition","isLtr","originX","originY","_a","_invertPosition","x","y","overlayPosition","overlayX","overlayY","_markForCheck","onMicrotaskEmpty","asObservable","take","tooltipClass","decorators","type","Directive","args","selector","exportAs","host","(longpress)","(keydown)","(touchend)","ctorParameters","ElementRef","ScrollDispatcher","ViewContainerRef","NgZone","Platform","AriaDescriber","FocusMonitor","undefined","Inject","Directionality","Optional","HAMMER_LOADER","propDecorators","Input","_changeDetectorRef","_breakpointObserver","_visibility","_closeOnInteraction","_onHide","_isHandset","observe","Breakpoints","Handset","clearTimeout","setTimeout","_animationStart","_animationDone","toState","_handleBodyInteraction","markForCheck","Component","moduleId","id","template","encapsulation","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","[style.zoom]","(body:click)","aria-hidden","styles","ChangeDetectorRef","BreakpointObserver","MatTooltipModule","NgModule","imports","A11yModule","CommonModule","OverlayModule","MatCommonModule","declarations","entryComponents","providers","HAMMER_GESTURE_CONFIG","useClass","GestureConfig","TOOLTIP_PANEL_CLASS"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/cdk/overlay'), require('@angular/cdk/a11y'), require('@angular/common'), require('@angular/core'), require('@angular/material/core'), require('@angular/platform-browser'), require('tslib'), require('@angular/cdk/bidi'), require('@angular/cdk/coercion'), require('@angular/cdk/keycodes'), require('@angular/cdk/layout'), require('@angular/cdk/platform'), require('@angular/cdk/portal'), require('@angular/cdk/scrolling'), require('rxjs'), require('rxjs/operators'), require('@angular/animations')) :\n    typeof define === 'function' && define.amd ? define('@angular/material/tooltip', ['exports', '@angular/cdk/overlay', '@angular/cdk/a11y', '@angular/common', '@angular/core', '@angular/material/core', '@angular/platform-browser', 'tslib', '@angular/cdk/bidi', '@angular/cdk/coercion', '@angular/cdk/keycodes', '@angular/cdk/layout', '@angular/cdk/platform', '@angular/cdk/portal', '@angular/cdk/scrolling', 'rxjs', 'rxjs/operators', '@angular/animations'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.tooltip = {}), global.ng.cdk.overlay, global.ng.cdk.a11y, global.ng.common, global.ng.core, global.ng.material.core, global.ng.platformBrowser, global.tslib, global.ng.cdk.bidi, global.ng.cdk.coercion, global.ng.cdk.keycodes, global.ng.cdk.layout, global.ng.cdk.platform, global.ng.cdk.portal, global.ng.cdk.scrolling, global.rxjs, global.rxjs.operators, global.ng.animations));\n}(this, function (exports, overlay, a11y, common, core, core$1, platformBrowser, tslib_1, bidi, coercion, keycodes, layout, platform, portal, scrolling, rxjs, operators, animations) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Animations used by MatTooltip.\n     * @docs-private\n     */\n    var matTooltipAnimations = {\n        /** Animation that transitions a tooltip in and out. */\n        tooltipState: animations.trigger('state', [\n            animations.state('initial, void, hidden', animations.style({ opacity: 0, transform: 'scale(0)' })),\n            animations.state('visible', animations.style({ transform: 'scale(1)' })),\n            animations.transition('* => visible', animations.animate('200ms cubic-bezier(0, 0, 0.2, 1)', animations.keyframes([\n                animations.style({ opacity: 0, transform: 'scale(0)', offset: 0 }),\n                animations.style({ opacity: 0.5, transform: 'scale(0.99)', offset: 0.5 }),\n                animations.style({ opacity: 1, transform: 'scale(1)', offset: 1 })\n            ]))),\n            animations.transition('* => hidden', animations.animate('100ms cubic-bezier(0, 0, 0.2, 1)', animations.style({ opacity: 0 }))),\n        ])\n    };\n\n    /** Time in ms to throttle repositioning after scroll events. */\n    var SCROLL_THROTTLE_MS = 20;\n    /** CSS class that will be attached to the overlay panel. */\n    var TOOLTIP_PANEL_CLASS = 'mat-tooltip-panel';\n    /**\n     * Creates an error to be thrown if the user supplied an invalid tooltip position.\n     * @docs-private\n     */\n    function getMatTooltipInvalidPositionError(position) {\n        return Error(\"Tooltip position \\\"\" + position + \"\\\" is invalid.\");\n    }\n    /** Injection token that determines the scroll handling while a tooltip is visible. */\n    var MAT_TOOLTIP_SCROLL_STRATEGY = new core.InjectionToken('mat-tooltip-scroll-strategy');\n    /** @docs-private */\n    function MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY(overlay) {\n        return function () { return overlay.scrollStrategies.reposition({ scrollThrottle: SCROLL_THROTTLE_MS }); };\n    }\n    /** @docs-private */\n    var MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n        provide: MAT_TOOLTIP_SCROLL_STRATEGY,\n        deps: [overlay.Overlay],\n        useFactory: MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY,\n    };\n    /** Injection token to be used to override the default options for `matTooltip`. */\n    var MAT_TOOLTIP_DEFAULT_OPTIONS = new core.InjectionToken('mat-tooltip-default-options', {\n        providedIn: 'root',\n        factory: MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY\n    });\n    /** @docs-private */\n    function MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY() {\n        return {\n            showDelay: 0,\n            hideDelay: 0,\n            touchendHideDelay: 1500,\n        };\n    }\n    /**\n     * Directive that attaches a material design tooltip to the host element. Animates the showing and\n     * hiding of a tooltip provided position (defaults to below the element).\n     *\n     * https://material.io/design/components/tooltips.html\n     */\n    var MatTooltip = /** @class */ (function () {\n        function MatTooltip(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, platform, _ariaDescriber, _focusMonitor, scrollStrategy, _dir, _defaultOptions, hammerLoader) {\n            var _this = this;\n            this._overlay = _overlay;\n            this._elementRef = _elementRef;\n            this._scrollDispatcher = _scrollDispatcher;\n            this._viewContainerRef = _viewContainerRef;\n            this._ngZone = _ngZone;\n            this._ariaDescriber = _ariaDescriber;\n            this._focusMonitor = _focusMonitor;\n            this._dir = _dir;\n            this._defaultOptions = _defaultOptions;\n            this._position = 'below';\n            this._disabled = false;\n            /** The default delay in ms before showing the tooltip after show is called */\n            this.showDelay = this._defaultOptions.showDelay;\n            /** The default delay in ms before hiding the tooltip after hide is called */\n            this.hideDelay = this._defaultOptions.hideDelay;\n            this._message = '';\n            this._manualListeners = new Map();\n            /** Emits when the component is destroyed. */\n            this._destroyed = new rxjs.Subject();\n            this._scrollStrategy = scrollStrategy;\n            var element = _elementRef.nativeElement;\n            var hasGestures = typeof window === 'undefined' || window.Hammer || hammerLoader;\n            // The mouse events shouldn't be bound on mobile devices, because they can prevent the\n            // first tap from firing its click event or can cause the tooltip to open for clicks.\n            if (!platform.IOS && !platform.ANDROID) {\n                this._manualListeners\n                    .set('mouseenter', function () { return _this.show(); })\n                    .set('mouseleave', function () { return _this.hide(); });\n            }\n            else if (!hasGestures) {\n                // If Hammerjs isn't loaded, fall back to showing on `touchstart`, otherwise\n                // there's no way for the user to trigger the tooltip on a touch device.\n                this._manualListeners.set('touchstart', function () { return _this.show(); });\n            }\n            this._manualListeners.forEach(function (listener, event) { return element.addEventListener(event, listener); });\n            _focusMonitor.monitor(_elementRef).pipe(operators.takeUntil(this._destroyed)).subscribe(function (origin) {\n                // Note that the focus monitor runs outside the Angular zone.\n                if (!origin) {\n                    _ngZone.run(function () { return _this.hide(0); });\n                }\n                else if (origin === 'keyboard') {\n                    _ngZone.run(function () { return _this.show(); });\n                }\n            });\n            if (_defaultOptions && _defaultOptions.position) {\n                this.position = _defaultOptions.position;\n            }\n        }\n        Object.defineProperty(MatTooltip.prototype, \"position\", {\n            /** Allows the user to define the position of the tooltip relative to the parent element */\n            get: function () { return this._position; },\n            set: function (value) {\n                if (value !== this._position) {\n                    this._position = value;\n                    if (this._overlayRef) {\n                        this._updatePosition();\n                        if (this._tooltipInstance) {\n                            this._tooltipInstance.show(0);\n                        }\n                        this._overlayRef.updatePosition();\n                    }\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatTooltip.prototype, \"disabled\", {\n            /** Disables the display of the tooltip. */\n            get: function () { return this._disabled; },\n            set: function (value) {\n                this._disabled = coercion.coerceBooleanProperty(value);\n                // If tooltip is disabled, hide immediately.\n                if (this._disabled) {\n                    this.hide(0);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatTooltip.prototype, \"message\", {\n            /** The message to be displayed in the tooltip */\n            get: function () { return this._message; },\n            set: function (value) {\n                var _this = this;\n                this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this._message);\n                // If the message is not a string (e.g. number), convert it to a string and trim it.\n                this._message = value != null ? (\"\" + value).trim() : '';\n                if (!this._message && this._isTooltipVisible()) {\n                    this.hide(0);\n                }\n                else {\n                    this._updateTooltipMessage();\n                    this._ngZone.runOutsideAngular(function () {\n                        // The `AriaDescriber` has some functionality that avoids adding a description if it's the\n                        // same as the `aria-label` of an element, however we can't know whether the tooltip trigger\n                        // has a data-bound `aria-label` or when it'll be set for the first time. We can avoid the\n                        // issue by deferring the description by a tick so Angular has time to set the `aria-label`.\n                        Promise.resolve().then(function () {\n                            _this._ariaDescriber.describe(_this._elementRef.nativeElement, _this.message);\n                        });\n                    });\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatTooltip.prototype, \"tooltipClass\", {\n            /** Classes to be passed to the tooltip. Supports the same syntax as `ngClass`. */\n            get: function () { return this._tooltipClass; },\n            set: function (value) {\n                this._tooltipClass = value;\n                if (this._tooltipInstance) {\n                    this._setTooltipClass(this._tooltipClass);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Setup styling-specific things\n         */\n        MatTooltip.prototype.ngOnInit = function () {\n            var element = this._elementRef.nativeElement;\n            var elementStyle = element.style;\n            if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {\n                // When we bind a gesture event on an element (in this case `longpress`), HammerJS\n                // will add some inline styles by default, including `user-select: none`. This is\n                // problematic on iOS and in Safari, because it will prevent users from typing in inputs.\n                // Since `user-select: none` is not needed for the `longpress` event and can cause unexpected\n                // behavior for text fields, we always clear the `user-select` to avoid such issues.\n                elementStyle.webkitUserSelect = elementStyle.userSelect = elementStyle.msUserSelect = '';\n            }\n            // Hammer applies `-webkit-user-drag: none` on all elements by default,\n            // which breaks the native drag&drop. If the consumer explicitly made\n            // the element draggable, clear the `-webkit-user-drag`.\n            if (element.draggable && elementStyle.webkitUserDrag === 'none') {\n                elementStyle.webkitUserDrag = '';\n            }\n        };\n        /**\n         * Dispose the tooltip when destroyed.\n         */\n        MatTooltip.prototype.ngOnDestroy = function () {\n            var _this = this;\n            if (this._overlayRef) {\n                this._overlayRef.dispose();\n                this._tooltipInstance = null;\n            }\n            // Clean up the event listeners set in the constructor\n            this._manualListeners.forEach(function (listener, event) {\n                _this._elementRef.nativeElement.removeEventListener(event, listener);\n            });\n            this._manualListeners.clear();\n            this._destroyed.next();\n            this._destroyed.complete();\n            this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this.message);\n            this._focusMonitor.stopMonitoring(this._elementRef);\n        };\n        /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */\n        MatTooltip.prototype.show = function (delay) {\n            var _this = this;\n            if (delay === void 0) { delay = this.showDelay; }\n            if (this.disabled || !this.message || (this._isTooltipVisible() &&\n                !this._tooltipInstance._showTimeoutId && !this._tooltipInstance._hideTimeoutId)) {\n                return;\n            }\n            var overlayRef = this._createOverlay();\n            this._detach();\n            this._portal = this._portal || new portal.ComponentPortal(TooltipComponent, this._viewContainerRef);\n            this._tooltipInstance = overlayRef.attach(this._portal).instance;\n            this._tooltipInstance.afterHidden()\n                .pipe(operators.takeUntil(this._destroyed))\n                .subscribe(function () { return _this._detach(); });\n            this._setTooltipClass(this._tooltipClass);\n            this._updateTooltipMessage();\n            this._tooltipInstance.show(delay);\n        };\n        /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */\n        MatTooltip.prototype.hide = function (delay) {\n            if (delay === void 0) { delay = this.hideDelay; }\n            if (this._tooltipInstance) {\n                this._tooltipInstance.hide(delay);\n            }\n        };\n        /** Shows/hides the tooltip */\n        MatTooltip.prototype.toggle = function () {\n            this._isTooltipVisible() ? this.hide() : this.show();\n        };\n        /** Returns true if the tooltip is currently visible to the user */\n        MatTooltip.prototype._isTooltipVisible = function () {\n            return !!this._tooltipInstance && this._tooltipInstance.isVisible();\n        };\n        /** Handles the keydown events on the host element. */\n        MatTooltip.prototype._handleKeydown = function (e) {\n            if (this._isTooltipVisible() && e.keyCode === keycodes.ESCAPE && !keycodes.hasModifierKey(e)) {\n                e.preventDefault();\n                e.stopPropagation();\n                this.hide(0);\n            }\n        };\n        /** Handles the touchend events on the host element. */\n        MatTooltip.prototype._handleTouchend = function () {\n            this.hide(this._defaultOptions.touchendHideDelay);\n        };\n        /** Create the overlay config and position strategy */\n        MatTooltip.prototype._createOverlay = function () {\n            var _this = this;\n            if (this._overlayRef) {\n                return this._overlayRef;\n            }\n            var scrollableAncestors = this._scrollDispatcher.getAncestorScrollContainers(this._elementRef);\n            // Create connected position strategy that listens for scroll events to reposition.\n            var strategy = this._overlay.position()\n                .flexibleConnectedTo(this._elementRef)\n                .withTransformOriginOn('.mat-tooltip')\n                .withFlexibleDimensions(false)\n                .withViewportMargin(8)\n                .withScrollableContainers(scrollableAncestors);\n            strategy.positionChanges.pipe(operators.takeUntil(this._destroyed)).subscribe(function (change) {\n                if (_this._tooltipInstance) {\n                    if (change.scrollableViewProperties.isOverlayClipped && _this._tooltipInstance.isVisible()) {\n                        // After position changes occur and the overlay is clipped by\n                        // a parent scrollable then close the tooltip.\n                        _this._ngZone.run(function () { return _this.hide(0); });\n                    }\n                }\n            });\n            this._overlayRef = this._overlay.create({\n                direction: this._dir,\n                positionStrategy: strategy,\n                panelClass: TOOLTIP_PANEL_CLASS,\n                scrollStrategy: this._scrollStrategy()\n            });\n            this._updatePosition();\n            this._overlayRef.detachments()\n                .pipe(operators.takeUntil(this._destroyed))\n                .subscribe(function () { return _this._detach(); });\n            return this._overlayRef;\n        };\n        /** Detaches the currently-attached tooltip. */\n        MatTooltip.prototype._detach = function () {\n            if (this._overlayRef && this._overlayRef.hasAttached()) {\n                this._overlayRef.detach();\n            }\n            this._tooltipInstance = null;\n        };\n        /** Updates the position of the current tooltip. */\n        MatTooltip.prototype._updatePosition = function () {\n            var position = this._overlayRef.getConfig().positionStrategy;\n            var origin = this._getOrigin();\n            var overlay = this._getOverlayPosition();\n            position.withPositions([\n                tslib_1.__assign({}, origin.main, overlay.main),\n                tslib_1.__assign({}, origin.fallback, overlay.fallback)\n            ]);\n        };\n        /**\n         * Returns the origin position and a fallback position based on the user's position preference.\n         * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).\n         */\n        MatTooltip.prototype._getOrigin = function () {\n            var isLtr = !this._dir || this._dir.value == 'ltr';\n            var position = this.position;\n            var originPosition;\n            if (position == 'above' || position == 'below') {\n                originPosition = { originX: 'center', originY: position == 'above' ? 'top' : 'bottom' };\n            }\n            else if (position == 'before' ||\n                (position == 'left' && isLtr) ||\n                (position == 'right' && !isLtr)) {\n                originPosition = { originX: 'start', originY: 'center' };\n            }\n            else if (position == 'after' ||\n                (position == 'right' && isLtr) ||\n                (position == 'left' && !isLtr)) {\n                originPosition = { originX: 'end', originY: 'center' };\n            }\n            else {\n                throw getMatTooltipInvalidPositionError(position);\n            }\n            var _a = this._invertPosition(originPosition.originX, originPosition.originY), x = _a.x, y = _a.y;\n            return {\n                main: originPosition,\n                fallback: { originX: x, originY: y }\n            };\n        };\n        /** Returns the overlay position and a fallback position based on the user's preference */\n        MatTooltip.prototype._getOverlayPosition = function () {\n            var isLtr = !this._dir || this._dir.value == 'ltr';\n            var position = this.position;\n            var overlayPosition;\n            if (position == 'above') {\n                overlayPosition = { overlayX: 'center', overlayY: 'bottom' };\n            }\n            else if (position == 'below') {\n                overlayPosition = { overlayX: 'center', overlayY: 'top' };\n            }\n            else if (position == 'before' ||\n                (position == 'left' && isLtr) ||\n                (position == 'right' && !isLtr)) {\n                overlayPosition = { overlayX: 'end', overlayY: 'center' };\n            }\n            else if (position == 'after' ||\n                (position == 'right' && isLtr) ||\n                (position == 'left' && !isLtr)) {\n                overlayPosition = { overlayX: 'start', overlayY: 'center' };\n            }\n            else {\n                throw getMatTooltipInvalidPositionError(position);\n            }\n            var _a = this._invertPosition(overlayPosition.overlayX, overlayPosition.overlayY), x = _a.x, y = _a.y;\n            return {\n                main: overlayPosition,\n                fallback: { overlayX: x, overlayY: y }\n            };\n        };\n        /** Updates the tooltip message and repositions the overlay according to the new message length */\n        MatTooltip.prototype._updateTooltipMessage = function () {\n            var _this = this;\n            // Must wait for the message to be painted to the tooltip so that the overlay can properly\n            // calculate the correct positioning based on the size of the text.\n            if (this._tooltipInstance) {\n                this._tooltipInstance.message = this.message;\n                this._tooltipInstance._markForCheck();\n                this._ngZone.onMicrotaskEmpty.asObservable().pipe(operators.take(1), operators.takeUntil(this._destroyed)).subscribe(function () {\n                    if (_this._tooltipInstance) {\n                        _this._overlayRef.updatePosition();\n                    }\n                });\n            }\n        };\n        /** Updates the tooltip class */\n        MatTooltip.prototype._setTooltipClass = function (tooltipClass) {\n            if (this._tooltipInstance) {\n                this._tooltipInstance.tooltipClass = tooltipClass;\n                this._tooltipInstance._markForCheck();\n            }\n        };\n        /** Inverts an overlay position. */\n        MatTooltip.prototype._invertPosition = function (x, y) {\n            if (this.position === 'above' || this.position === 'below') {\n                if (y === 'top') {\n                    y = 'bottom';\n                }\n                else if (y === 'bottom') {\n                    y = 'top';\n                }\n            }\n            else {\n                if (x === 'end') {\n                    x = 'start';\n                }\n                else if (x === 'start') {\n                    x = 'end';\n                }\n            }\n            return { x: x, y: y };\n        };\n        MatTooltip.decorators = [\n            { type: core.Directive, args: [{\n                        selector: '[matTooltip]',\n                        exportAs: 'matTooltip',\n                        host: {\n                            '(longpress)': 'show()',\n                            '(keydown)': '_handleKeydown($event)',\n                            '(touchend)': '_handleTouchend()',\n                        },\n                    },] }\n        ];\n        /** @nocollapse */\n        MatTooltip.ctorParameters = function () { return [\n            { type: overlay.Overlay },\n            { type: core.ElementRef },\n            { type: scrolling.ScrollDispatcher },\n            { type: core.ViewContainerRef },\n            { type: core.NgZone },\n            { type: platform.Platform },\n            { type: a11y.AriaDescriber },\n            { type: a11y.FocusMonitor },\n            { type: undefined, decorators: [{ type: core.Inject, args: [MAT_TOOLTIP_SCROLL_STRATEGY,] }] },\n            { type: bidi.Directionality, decorators: [{ type: core.Optional }] },\n            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_TOOLTIP_DEFAULT_OPTIONS,] }] },\n            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [platformBrowser.HAMMER_LOADER,] }] }\n        ]; };\n        MatTooltip.propDecorators = {\n            position: [{ type: core.Input, args: ['matTooltipPosition',] }],\n            disabled: [{ type: core.Input, args: ['matTooltipDisabled',] }],\n            showDelay: [{ type: core.Input, args: ['matTooltipShowDelay',] }],\n            hideDelay: [{ type: core.Input, args: ['matTooltipHideDelay',] }],\n            message: [{ type: core.Input, args: ['matTooltip',] }],\n            tooltipClass: [{ type: core.Input, args: ['matTooltipClass',] }]\n        };\n        return MatTooltip;\n    }());\n    /**\n     * Internal component that wraps the tooltip's content.\n     * @docs-private\n     */\n    var TooltipComponent = /** @class */ (function () {\n        function TooltipComponent(_changeDetectorRef, _breakpointObserver) {\n            this._changeDetectorRef = _changeDetectorRef;\n            this._breakpointObserver = _breakpointObserver;\n            /** Property watched by the animation framework to show or hide the tooltip */\n            this._visibility = 'initial';\n            /** Whether interactions on the page should close the tooltip */\n            this._closeOnInteraction = false;\n            /** Subject for notifying that the tooltip has been hidden from the view */\n            this._onHide = new rxjs.Subject();\n            /** Stream that emits whether the user has a handset-sized display.  */\n            this._isHandset = this._breakpointObserver.observe(layout.Breakpoints.Handset);\n        }\n        /**\n         * Shows the tooltip with an animation originating from the provided origin\n         * @param delay Amount of milliseconds to the delay showing the tooltip.\n         */\n        TooltipComponent.prototype.show = function (delay) {\n            var _this = this;\n            // Cancel the delayed hide if it is scheduled\n            if (this._hideTimeoutId) {\n                clearTimeout(this._hideTimeoutId);\n                this._hideTimeoutId = null;\n            }\n            // Body interactions should cancel the tooltip if there is a delay in showing.\n            this._closeOnInteraction = true;\n            this._showTimeoutId = setTimeout(function () {\n                _this._visibility = 'visible';\n                _this._showTimeoutId = null;\n                // Mark for check so if any parent component has set the\n                // ChangeDetectionStrategy to OnPush it will be checked anyways\n                _this._markForCheck();\n            }, delay);\n        };\n        /**\n         * Begins the animation to hide the tooltip after the provided delay in ms.\n         * @param delay Amount of milliseconds to delay showing the tooltip.\n         */\n        TooltipComponent.prototype.hide = function (delay) {\n            var _this = this;\n            // Cancel the delayed show if it is scheduled\n            if (this._showTimeoutId) {\n                clearTimeout(this._showTimeoutId);\n                this._showTimeoutId = null;\n            }\n            this._hideTimeoutId = setTimeout(function () {\n                _this._visibility = 'hidden';\n                _this._hideTimeoutId = null;\n                // Mark for check so if any parent component has set the\n                // ChangeDetectionStrategy to OnPush it will be checked anyways\n                _this._markForCheck();\n            }, delay);\n        };\n        /** Returns an observable that notifies when the tooltip has been hidden from view. */\n        TooltipComponent.prototype.afterHidden = function () {\n            return this._onHide.asObservable();\n        };\n        /** Whether the tooltip is being displayed. */\n        TooltipComponent.prototype.isVisible = function () {\n            return this._visibility === 'visible';\n        };\n        TooltipComponent.prototype.ngOnDestroy = function () {\n            this._onHide.complete();\n        };\n        TooltipComponent.prototype._animationStart = function () {\n            this._closeOnInteraction = false;\n        };\n        TooltipComponent.prototype._animationDone = function (event) {\n            var toState = event.toState;\n            if (toState === 'hidden' && !this.isVisible()) {\n                this._onHide.next();\n            }\n            if (toState === 'visible' || toState === 'hidden') {\n                this._closeOnInteraction = true;\n            }\n        };\n        /**\n         * Interactions on the HTML body should close the tooltip immediately as defined in the\n         * material design spec.\n         * https://material.io/design/components/tooltips.html#behavior\n         */\n        TooltipComponent.prototype._handleBodyInteraction = function () {\n            if (this._closeOnInteraction) {\n                this.hide(0);\n            }\n        };\n        /**\n         * Marks that the tooltip needs to be checked in the next change detection run.\n         * Mainly used for rendering the initial text before positioning a tooltip, which\n         * can be problematic in components with OnPush change detection.\n         */\n        TooltipComponent.prototype._markForCheck = function () {\n            this._changeDetectorRef.markForCheck();\n        };\n        TooltipComponent.decorators = [\n            { type: core.Component, args: [{\n                        moduleId: module.id,\n                        selector: 'mat-tooltip-component',\n                        template: \"<div class=\\\"mat-tooltip\\\"\\n     [ngClass]=\\\"tooltipClass\\\"\\n     [class.mat-tooltip-handset]=\\\"(_isHandset | async)?.matches\\\"\\n     [@state]=\\\"_visibility\\\"\\n     (@state.start)=\\\"_animationStart()\\\"\\n     (@state.done)=\\\"_animationDone($event)\\\">{{message}}</div>\\n\",\n                        encapsulation: core.ViewEncapsulation.None,\n                        changeDetection: core.ChangeDetectionStrategy.OnPush,\n                        animations: [matTooltipAnimations.tooltipState],\n                        host: {\n                            // Forces the element to have a layout in IE and Edge. This fixes issues where the element\n                            // won't be rendered if the animations are disabled or there is no web animations polyfill.\n                            '[style.zoom]': '_visibility === \"visible\" ? 1 : null',\n                            '(body:click)': 'this._handleBodyInteraction()',\n                            'aria-hidden': 'true',\n                        },\n                        styles: [\".mat-tooltip-panel{pointer-events:none !important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}@media(-ms-high-contrast: active){.mat-tooltip{outline:solid 1px}}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}/*# sourceMappingURL=tooltip.css.map */\\n\"]\n                    }] }\n        ];\n        /** @nocollapse */\n        TooltipComponent.ctorParameters = function () { return [\n            { type: core.ChangeDetectorRef },\n            { type: layout.BreakpointObserver }\n        ]; };\n        return TooltipComponent;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var MatTooltipModule = /** @class */ (function () {\n        function MatTooltipModule() {\n        }\n        MatTooltipModule.decorators = [\n            { type: core.NgModule, args: [{\n                        imports: [\n                            a11y.A11yModule,\n                            common.CommonModule,\n                            overlay.OverlayModule,\n                            core$1.MatCommonModule,\n                        ],\n                        exports: [MatTooltip, TooltipComponent, core$1.MatCommonModule],\n                        declarations: [MatTooltip, TooltipComponent],\n                        entryComponents: [TooltipComponent],\n                        providers: [\n                            MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER,\n                            { provide: platformBrowser.HAMMER_GESTURE_CONFIG, useClass: core$1.GestureConfig },\n                        ]\n                    },] }\n        ];\n        return MatTooltipModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.MatTooltipModule = MatTooltipModule;\n    exports.SCROLL_THROTTLE_MS = SCROLL_THROTTLE_MS;\n    exports.TOOLTIP_PANEL_CLASS = TOOLTIP_PANEL_CLASS;\n    exports.getMatTooltipInvalidPositionError = getMatTooltipInvalidPositionError;\n    exports.MAT_TOOLTIP_SCROLL_STRATEGY = MAT_TOOLTIP_SCROLL_STRATEGY;\n    exports.MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY = MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY;\n    exports.MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER = MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER;\n    exports.MAT_TOOLTIP_DEFAULT_OPTIONS = MAT_TOOLTIP_DEFAULT_OPTIONS;\n    exports.MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY = MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY;\n    exports.MatTooltip = MatTooltip;\n    exports.TooltipComponent = TooltipComponent;\n    exports.matTooltipAnimations = matTooltipAnimations;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=material-tooltip.umd.js.map\n"]}