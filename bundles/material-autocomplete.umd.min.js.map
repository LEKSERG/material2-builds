{"version":3,"sources":["src/material/material-autocomplete.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","material","autocomplete","tslib","cdk","a11y","coercion","core","common","overlay","bidi","keycodes","platform","portal","scrolling","forms","formField","rxjs","operators","this","tslib_1","core$1","_uniqueAutocompleteIdCounter","MatAutocompleteSelectedEvent","source","option","_MatAutocompleteMixinBase","mixinDisableRipple","MatAutocompleteBase","MAT_AUTOCOMPLETE_DEFAULT_OPTIONS","InjectionToken","providedIn","MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY","autoActiveFirstOption","MatAutocomplete","_super","_changeDetectorRef","_elementRef","defaults","_this","call","showPanel","_isOpen","displayWith","optionSelected","EventEmitter","opened","closed","_classList","id","_autoActiveFirstOption","__extends","Object","defineProperty","prototype","get","enumerable","configurable","set","value","coerceBooleanProperty","length","split","reduce","classList","className","trim","_setVisibilityClasses","nativeElement","ngAfterContentInit","_keyManager","ActiveDescendantKeyManager","options","withWrap","_setVisibility","_setScrollTop","scrollTop","panel","_getScrollTop","markForCheck","_emitSelectEvent","event","emit","decorators","type","Component","args","moduleId","selector","template","encapsulation","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","exportAs","inputs","host","class","providers","provide","MAT_OPTION_PARENT_COMPONENT","useExisting","styles","ctorParameters","ChangeDetectorRef","ElementRef","undefined","Inject","propDecorators","ViewChild","TemplateRef","static","ContentChildren","MatOption","descendants","optionGroups","MatOptgroup","Input","panelWidth","Output","MatAutocompleteOrigin","elementRef","Directive","MAT_AUTOCOMPLETE_SCROLL_STRATEGY","MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY","scrollStrategies","reposition","MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER","deps","Overlay","useFactory","MAT_AUTOCOMPLETE_VALUE_ACCESSOR","NG_VALUE_ACCESSOR","forwardRef","MatAutocompleteTrigger","multi","getMatAutocompleteMissingPanelError","Error","_element","_overlay","_viewContainerRef","_zone","scrollStrategy","_dir","_formField","_document","_viewportRuler","_componentDestroyed","_autocompleteDisabled","_manuallyFloatingLabel","_viewportSubscription","Subscription","EMPTY","_canOpenOnNextFocus","_closeKeyEventStream","Subject","_windowBlurHandler","activeElement","panelOpen","_onChange","_onTouched","position","autocompleteAttribute","_overlayAttached","optionSelections","defer","merge","apply","__spread","map","onSelectionChange","onStable","asObservable","pipe","take","switchMap","_scrollStrategy","ngAfterViewInit","window","runOutsideAngular","addEventListener","_supportsShadowDom","element","rootNode","getRootNode","_isInsideShadowRoot","ShadowRoot","ngOnChanges","changes","_positionStrategy","_setStrategyPositions","_overlayRef","updatePosition","ngOnDestroy","removeEventListener","unsubscribe","_destroyPanel","complete","openPanel","_attachOverlay","_floatLabel","closePanel","_resetLabel","hasAttached","detach","_closingActionsSubscription","detectChanges","tabOut","filter","_getOutsideClickStream","detachments","of","MatOptionSelectionChange","activeItem","fromEvent","clickTarget","composedPath","target","contains","overlayElement","writeValue","Promise","resolve","then","_setTriggerValue","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","disabled","_handleKeydown","keyCode","ESCAPE","preventDefault","activeOption","ENTER","_selectViaInteraction","_resetActiveItem","prevActiveItem","isArrowKey","UP_ARROW","DOWN_ARROW","TAB","onKeydown","_canOpen","_scrollToOption","_handleInput","parseFloat","_previousValue","_handleFocus","shouldAnimate","floatLabel","_animateAndLockLabel","index","activeItemIndex","labelCount","_countGroupLabelsBeforeOption","newScrollPosition","_getOptionScrollPosition","_subscribeToClosingActions","firstStable","optionChanges","tap","reapplyLastPosition","delay","wasOpen","panelClosingActions","subscribe","_setValueAndClose","dispose","toDisplay","inputValue","_control","_clearPreviousSelectedOption","focus","skip","forEach","selected","deselect","overlayRef","setOrigin","_getConnectedElement","updateSize","width","_getPanelWidth","_portal","TemplatePortal","create","_getOverlayConfig","keydownEvents","altKey","next","stopPropagation","change","attach","OverlayConfig","positionStrategy","_getOverlayPosition","direction","strategy","flexibleConnectedTo","withFlexibleDimensions","withPush","belowPosition","originX","originY","overlayX","overlayY","abovePosition","panelClass","withPositions","connectedTo","getConnectedOverlayOrigin","_getHostWidth","getBoundingClientRect","setActiveItem","readOnly","[attr.autocomplete]","[attr.role]","[attr.aria-autocomplete]","[attr.aria-activedescendant]","[attr.aria-expanded]","[attr.aria-owns]","[attr.aria-haspopup]","(focusin)","(blur)","(input)","(keydown)","ViewContainerRef","NgZone","Directionality","Optional","MatFormField","Host","DOCUMENT","ViewportRuler","autocompleteDisabled","MatAutocompleteModule","NgModule","imports","MatOptionModule","OverlayModule","MatCommonModule","CommonModule","declarations","AUTOCOMPLETE_OPTION_HEIGHT","AUTOCOMPLETE_PANEL_HEIGHT"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('@angular/cdk/a11y'), require('@angular/cdk/coercion'), require('@angular/core'), require('@angular/material/core'), require('@angular/common'), require('@angular/cdk/overlay'), require('@angular/cdk/bidi'), require('@angular/cdk/keycodes'), require('@angular/cdk/platform'), require('@angular/cdk/portal'), require('@angular/cdk/scrolling'), require('@angular/forms'), require('@angular/material/form-field'), require('rxjs'), require('rxjs/operators')) :\n    typeof define === 'function' && define.amd ? define('@angular/material/autocomplete', ['exports', 'tslib', '@angular/cdk/a11y', '@angular/cdk/coercion', '@angular/core', '@angular/material/core', '@angular/common', '@angular/cdk/overlay', '@angular/cdk/bidi', '@angular/cdk/keycodes', '@angular/cdk/platform', '@angular/cdk/portal', '@angular/cdk/scrolling', '@angular/forms', '@angular/material/form-field', 'rxjs', 'rxjs/operators'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.autocomplete = {}), global.tslib, global.ng.cdk.a11y, global.ng.cdk.coercion, global.ng.core, global.ng.material.core, global.ng.common, global.ng.cdk.overlay, global.ng.cdk.bidi, global.ng.cdk.keycodes, global.ng.cdk.platform, global.ng.cdk.portal, global.ng.cdk.scrolling, global.ng.forms, global.ng.material.formField, global.rxjs, global.rxjs.operators));\n}(this, function (exports, tslib_1, a11y, coercion, core, core$1, common, overlay, bidi, keycodes, platform, portal, scrolling, forms, formField, rxjs, operators) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Autocomplete IDs need to be unique across components, so this counter exists outside of\n     * the component definition.\n     */\n    var _uniqueAutocompleteIdCounter = 0;\n    /** Event object that is emitted when an autocomplete option is selected. */\n    var MatAutocompleteSelectedEvent = /** @class */ (function () {\n        function MatAutocompleteSelectedEvent(\n        /** Reference to the autocomplete panel that emitted the event. */\n        source, \n        /** Option that was selected. */\n        option) {\n            this.source = source;\n            this.option = option;\n        }\n        return MatAutocompleteSelectedEvent;\n    }());\n    // Boilerplate for applying mixins to MatAutocomplete.\n    /** @docs-private */\n    var MatAutocompleteBase = /** @class */ (function () {\n        function MatAutocompleteBase() {\n        }\n        return MatAutocompleteBase;\n    }());\n    var _MatAutocompleteMixinBase = core$1.mixinDisableRipple(MatAutocompleteBase);\n    /** Injection token to be used to override the default options for `mat-autocomplete`. */\n    var MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new core.InjectionToken('mat-autocomplete-default-options', {\n        providedIn: 'root',\n        factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY,\n    });\n    /** @docs-private */\n    function MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {\n        return { autoActiveFirstOption: false };\n    }\n    var MatAutocomplete = /** @class */ (function (_super) {\n        tslib_1.__extends(MatAutocomplete, _super);\n        function MatAutocomplete(_changeDetectorRef, _elementRef, defaults) {\n            var _this = _super.call(this) || this;\n            _this._changeDetectorRef = _changeDetectorRef;\n            _this._elementRef = _elementRef;\n            /** Whether the autocomplete panel should be visible, depending on option length. */\n            _this.showPanel = false;\n            _this._isOpen = false;\n            /** Function that maps an option's control value to its display value in the trigger. */\n            _this.displayWith = null;\n            /** Event that is emitted whenever an option from the list is selected. */\n            _this.optionSelected = new core.EventEmitter();\n            /** Event that is emitted when the autocomplete panel is opened. */\n            _this.opened = new core.EventEmitter();\n            /** Event that is emitted when the autocomplete panel is closed. */\n            _this.closed = new core.EventEmitter();\n            _this._classList = {};\n            /** Unique ID to be used by autocomplete trigger's \"aria-owns\" property. */\n            _this.id = \"mat-autocomplete-\" + _uniqueAutocompleteIdCounter++;\n            _this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;\n            return _this;\n        }\n        Object.defineProperty(MatAutocomplete.prototype, \"isOpen\", {\n            /** Whether the autocomplete panel is open. */\n            get: function () { return this._isOpen && this.showPanel; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatAutocomplete.prototype, \"autoActiveFirstOption\", {\n            /**\n             * Whether the first option should be highlighted when the autocomplete panel is opened.\n             * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n             */\n            get: function () { return this._autoActiveFirstOption; },\n            set: function (value) {\n                this._autoActiveFirstOption = coercion.coerceBooleanProperty(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatAutocomplete.prototype, \"classList\", {\n            /**\n             * Takes classes set on the host mat-autocomplete element and applies them to the panel\n             * inside the overlay container to allow for easy styling.\n             */\n            set: function (value) {\n                if (value && value.length) {\n                    this._classList = value.split(' ').reduce(function (classList, className) {\n                        classList[className.trim()] = true;\n                        return classList;\n                    }, {});\n                }\n                else {\n                    this._classList = {};\n                }\n                this._setVisibilityClasses(this._classList);\n                this._elementRef.nativeElement.className = '';\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MatAutocomplete.prototype.ngAfterContentInit = function () {\n            this._keyManager = new a11y.ActiveDescendantKeyManager(this.options).withWrap();\n            // Set the initial visibility state.\n            this._setVisibility();\n        };\n        /**\n         * Sets the panel scrollTop. This allows us to manually scroll to display options\n         * above or below the fold, as they are not actually being focused when active.\n         */\n        MatAutocomplete.prototype._setScrollTop = function (scrollTop) {\n            if (this.panel) {\n                this.panel.nativeElement.scrollTop = scrollTop;\n            }\n        };\n        /** Returns the panel's scrollTop. */\n        MatAutocomplete.prototype._getScrollTop = function () {\n            return this.panel ? this.panel.nativeElement.scrollTop : 0;\n        };\n        /** Panel should hide itself when the option list is empty. */\n        MatAutocomplete.prototype._setVisibility = function () {\n            this.showPanel = !!this.options.length;\n            this._setVisibilityClasses(this._classList);\n            this._changeDetectorRef.markForCheck();\n        };\n        /** Emits the `select` event. */\n        MatAutocomplete.prototype._emitSelectEvent = function (option) {\n            var event = new MatAutocompleteSelectedEvent(this, option);\n            this.optionSelected.emit(event);\n        };\n        /** Sets the autocomplete visibility classes on a classlist based on the panel is visible. */\n        MatAutocomplete.prototype._setVisibilityClasses = function (classList) {\n            classList['mat-autocomplete-visible'] = this.showPanel;\n            classList['mat-autocomplete-hidden'] = !this.showPanel;\n        };\n        MatAutocomplete.decorators = [\n            { type: core.Component, args: [{\n                        moduleId: module.id,\n                        selector: 'mat-autocomplete',\n                        template: \"<ng-template>\\n  <div class=\\\"mat-autocomplete-panel\\\" role=\\\"listbox\\\" [id]=\\\"id\\\" [ngClass]=\\\"_classList\\\" #panel>\\n    <ng-content></ng-content>\\n  </div>\\n</ng-template>\\n\",\n                        encapsulation: core.ViewEncapsulation.None,\n                        changeDetection: core.ChangeDetectionStrategy.OnPush,\n                        exportAs: 'matAutocomplete',\n                        inputs: ['disableRipple'],\n                        host: {\n                            'class': 'mat-autocomplete'\n                        },\n                        providers: [\n                            { provide: core$1.MAT_OPTION_PARENT_COMPONENT, useExisting: MatAutocomplete }\n                        ],\n                        styles: [\".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}@media(-ms-high-contrast: active){.mat-autocomplete-panel{outline:solid 1px}}\\n\"]\n                    }] }\n        ];\n        /** @nocollapse */\n        MatAutocomplete.ctorParameters = function () { return [\n            { type: core.ChangeDetectorRef },\n            { type: core.ElementRef },\n            { type: undefined, decorators: [{ type: core.Inject, args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,] }] }\n        ]; };\n        MatAutocomplete.propDecorators = {\n            template: [{ type: core.ViewChild, args: [core.TemplateRef, { static: true },] }],\n            panel: [{ type: core.ViewChild, args: ['panel', { static: false },] }],\n            options: [{ type: core.ContentChildren, args: [core$1.MatOption, { descendants: true },] }],\n            optionGroups: [{ type: core.ContentChildren, args: [core$1.MatOptgroup,] }],\n            displayWith: [{ type: core.Input }],\n            autoActiveFirstOption: [{ type: core.Input }],\n            panelWidth: [{ type: core.Input }],\n            optionSelected: [{ type: core.Output }],\n            opened: [{ type: core.Output }],\n            closed: [{ type: core.Output }],\n            classList: [{ type: core.Input, args: ['class',] }]\n        };\n        return MatAutocomplete;\n    }(_MatAutocompleteMixinBase));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Directive applied to an element to make it usable\n     * as a connection point for an autocomplete panel.\n     */\n    var MatAutocompleteOrigin = /** @class */ (function () {\n        function MatAutocompleteOrigin(\n        /** Reference to the element on which the directive is applied. */\n        elementRef) {\n            this.elementRef = elementRef;\n        }\n        MatAutocompleteOrigin.decorators = [\n            { type: core.Directive, args: [{\n                        selector: '[matAutocompleteOrigin]',\n                        exportAs: 'matAutocompleteOrigin',\n                    },] }\n        ];\n        /** @nocollapse */\n        MatAutocompleteOrigin.ctorParameters = function () { return [\n            { type: core.ElementRef }\n        ]; };\n        return MatAutocompleteOrigin;\n    }());\n\n    /**\n     * The following style constants are necessary to save here in order\n     * to properly calculate the scrollTop of the panel. Because we are not\n     * actually focusing the active item, scroll must be handled manually.\n     */\n    /** The height of each autocomplete option. */\n    var AUTOCOMPLETE_OPTION_HEIGHT = 48;\n    /** The total height of the autocomplete panel. */\n    var AUTOCOMPLETE_PANEL_HEIGHT = 256;\n    /** Injection token that determines the scroll handling while the autocomplete panel is open. */\n    var MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new core.InjectionToken('mat-autocomplete-scroll-strategy');\n    /** @docs-private */\n    function MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {\n        return function () { return overlay.scrollStrategies.reposition(); };\n    }\n    /** @docs-private */\n    var MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n        provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,\n        deps: [overlay.Overlay],\n        useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY,\n    };\n    /**\n     * Provider that allows the autocomplete to register as a ControlValueAccessor.\n     * @docs-private\n     */\n    var MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {\n        provide: forms.NG_VALUE_ACCESSOR,\n        useExisting: core.forwardRef(function () { return MatAutocompleteTrigger; }),\n        multi: true\n    };\n    /**\n     * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n     * @docs-private\n     */\n    function getMatAutocompleteMissingPanelError() {\n        return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' +\n            'Make sure that the id passed to the `matAutocomplete` is correct and that ' +\n            'you\\'re attempting to open it after the ngAfterContentInit hook.');\n    }\n    var MatAutocompleteTrigger = /** @class */ (function () {\n        function MatAutocompleteTrigger(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, \n        // @breaking-change 8.0.0 Make `_viewportRuler` required.\n        _viewportRuler) {\n            var _this = this;\n            this._element = _element;\n            this._overlay = _overlay;\n            this._viewContainerRef = _viewContainerRef;\n            this._zone = _zone;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._dir = _dir;\n            this._formField = _formField;\n            this._document = _document;\n            this._viewportRuler = _viewportRuler;\n            this._componentDestroyed = false;\n            this._autocompleteDisabled = false;\n            /** Whether or not the label state is being overridden. */\n            this._manuallyFloatingLabel = false;\n            /** Subscription to viewport size changes. */\n            this._viewportSubscription = rxjs.Subscription.EMPTY;\n            /**\n             * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n             * closed autocomplete from being reopened if the user switches to another browser tab and then\n             * comes back.\n             */\n            this._canOpenOnNextFocus = true;\n            /** Stream of keyboard events that can close the panel. */\n            this._closeKeyEventStream = new rxjs.Subject();\n            /**\n             * Event handler for when the window is blurred. Needs to be an\n             * arrow function in order to preserve the context.\n             */\n            this._windowBlurHandler = function () {\n                // If the user blurred the window while the autocomplete is focused, it means that it'll be\n                // refocused when they come back. In this case we want to skip the first focus event, if the\n                // pane was closed, in order to avoid reopening it unintentionally.\n                _this._canOpenOnNextFocus =\n                    _this._document.activeElement !== _this._element.nativeElement || _this.panelOpen;\n            };\n            /** `View -> model callback called when value changes` */\n            this._onChange = function () { };\n            /** `View -> model callback called when autocomplete has been touched` */\n            this._onTouched = function () { };\n            /**\n             * Position of the autocomplete panel relative to the trigger element. A position of `auto`\n             * will render the panel underneath the trigger if there is enough space for it to fit in\n             * the viewport, otherwise the panel will be shown above it. If the position is set to\n             * `above` or `below`, the panel will always be shown above or below the trigger. no matter\n             * whether it fits completely in the viewport.\n             */\n            this.position = 'auto';\n            /**\n             * `autocomplete` attribute to be set on the input element.\n             * @docs-private\n             */\n            this.autocompleteAttribute = 'off';\n            this._overlayAttached = false;\n            /** Stream of autocomplete option selections. */\n            this.optionSelections = rxjs.defer(function () {\n                if (_this.autocomplete && _this.autocomplete.options) {\n                    return rxjs.merge.apply(void 0, tslib_1.__spread(_this.autocomplete.options.map(function (option) { return option.onSelectionChange; })));\n                }\n                // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n                // Return a stream that we'll replace with the real one once everything is in place.\n                return _this._zone.onStable\n                    .asObservable()\n                    .pipe(operators.take(1), operators.switchMap(function () { return _this.optionSelections; }));\n            });\n            this._scrollStrategy = scrollStrategy;\n        }\n        Object.defineProperty(MatAutocompleteTrigger.prototype, \"autocompleteDisabled\", {\n            /**\n             * Whether the autocomplete is disabled. When disabled, the element will\n             * act as a regular input and the user won't be able to open the panel.\n             */\n            get: function () { return this._autocompleteDisabled; },\n            set: function (value) {\n                this._autocompleteDisabled = coercion.coerceBooleanProperty(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MatAutocompleteTrigger.prototype.ngAfterViewInit = function () {\n            var _this = this;\n            if (typeof window !== 'undefined') {\n                this._zone.runOutsideAngular(function () {\n                    window.addEventListener('blur', _this._windowBlurHandler);\n                });\n                if (platform._supportsShadowDom()) {\n                    var element = this._element.nativeElement;\n                    var rootNode = element.getRootNode ? element.getRootNode() : null;\n                    // We need to take the `ShadowRoot` off of `window`, because the built-in types are\n                    // incorrect. See https://github.com/Microsoft/TypeScript/issues/27929.\n                    this._isInsideShadowRoot = rootNode instanceof window.ShadowRoot;\n                }\n            }\n        };\n        MatAutocompleteTrigger.prototype.ngOnChanges = function (changes) {\n            if (changes['position'] && this._positionStrategy) {\n                this._setStrategyPositions(this._positionStrategy);\n                if (this.panelOpen) {\n                    this._overlayRef.updatePosition();\n                }\n            }\n        };\n        MatAutocompleteTrigger.prototype.ngOnDestroy = function () {\n            if (typeof window !== 'undefined') {\n                window.removeEventListener('blur', this._windowBlurHandler);\n            }\n            this._viewportSubscription.unsubscribe();\n            this._componentDestroyed = true;\n            this._destroyPanel();\n            this._closeKeyEventStream.complete();\n        };\n        Object.defineProperty(MatAutocompleteTrigger.prototype, \"panelOpen\", {\n            /** Whether or not the autocomplete panel is open. */\n            get: function () {\n                return this._overlayAttached && this.autocomplete.showPanel;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** Opens the autocomplete suggestion panel. */\n        MatAutocompleteTrigger.prototype.openPanel = function () {\n            this._attachOverlay();\n            this._floatLabel();\n        };\n        /** Closes the autocomplete suggestion panel. */\n        MatAutocompleteTrigger.prototype.closePanel = function () {\n            this._resetLabel();\n            if (!this._overlayAttached) {\n                return;\n            }\n            if (this.panelOpen) {\n                // Only emit if the panel was visible.\n                this.autocomplete.closed.emit();\n            }\n            this.autocomplete._isOpen = this._overlayAttached = false;\n            if (this._overlayRef && this._overlayRef.hasAttached()) {\n                this._overlayRef.detach();\n                this._closingActionsSubscription.unsubscribe();\n            }\n            // Note that in some cases this can end up being called after the component is destroyed.\n            // Add a check to ensure that we don't try to run change detection on a destroyed view.\n            if (!this._componentDestroyed) {\n                // We need to trigger change detection manually, because\n                // `fromEvent` doesn't seem to do it at the proper time.\n                // This ensures that the label is reset when the\n                // user clicks outside.\n                this._changeDetectorRef.detectChanges();\n            }\n        };\n        /**\n         * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n         * within the viewport.\n         */\n        MatAutocompleteTrigger.prototype.updatePosition = function () {\n            if (this._overlayAttached) {\n                this._overlayRef.updatePosition();\n            }\n        };\n        Object.defineProperty(MatAutocompleteTrigger.prototype, \"panelClosingActions\", {\n            /**\n             * A stream of actions that should close the autocomplete panel, including\n             * when an option is selected, on blur, and when TAB is pressed.\n             */\n            get: function () {\n                var _this = this;\n                return rxjs.merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(operators.filter(function () { return _this._overlayAttached; })), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ?\n                    this._overlayRef.detachments().pipe(operators.filter(function () { return _this._overlayAttached; })) :\n                    rxjs.of()).pipe(\n                // Normalize the output so we return a consistent type.\n                operators.map(function (event) { return event instanceof core$1.MatOptionSelectionChange ? event : null; }));\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatAutocompleteTrigger.prototype, \"activeOption\", {\n            /** The currently active option, coerced to MatOption type. */\n            get: function () {\n                if (this.autocomplete && this.autocomplete._keyManager) {\n                    return this.autocomplete._keyManager.activeItem;\n                }\n                return null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** Stream of clicks outside of the autocomplete panel. */\n        MatAutocompleteTrigger.prototype._getOutsideClickStream = function () {\n            var _this = this;\n            return rxjs.merge(rxjs.fromEvent(this._document, 'click'), rxjs.fromEvent(this._document, 'touchend'))\n                .pipe(operators.filter(function (event) {\n                // If we're in the Shadow DOM, the event target will be the shadow root, so we have to\n                // fall back to check the first element in the path of the click event.\n                var clickTarget = (_this._isInsideShadowRoot && event.composedPath ? event.composedPath()[0] :\n                    event.target);\n                var formField = _this._formField ? _this._formField._elementRef.nativeElement : null;\n                return _this._overlayAttached && clickTarget !== _this._element.nativeElement &&\n                    (!formField || !formField.contains(clickTarget)) &&\n                    (!!_this._overlayRef && !_this._overlayRef.overlayElement.contains(clickTarget));\n            }));\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatAutocompleteTrigger.prototype.writeValue = function (value) {\n            var _this = this;\n            Promise.resolve(null).then(function () { return _this._setTriggerValue(value); });\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatAutocompleteTrigger.prototype.registerOnChange = function (fn) {\n            this._onChange = fn;\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatAutocompleteTrigger.prototype.registerOnTouched = function (fn) {\n            this._onTouched = fn;\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatAutocompleteTrigger.prototype.setDisabledState = function (isDisabled) {\n            this._element.nativeElement.disabled = isDisabled;\n        };\n        MatAutocompleteTrigger.prototype._handleKeydown = function (event) {\n            var keyCode = event.keyCode;\n            // Prevent the default action on all escape key presses. This is here primarily to bring IE\n            // in line with other browsers. By default, pressing escape on IE will cause it to revert\n            // the input value to the one that it had on focus, however it won't dispatch any events\n            // which means that the model value will be out of sync with the view.\n            if (keyCode === keycodes.ESCAPE) {\n                event.preventDefault();\n            }\n            if (this.activeOption && keyCode === keycodes.ENTER && this.panelOpen) {\n                this.activeOption._selectViaInteraction();\n                this._resetActiveItem();\n                event.preventDefault();\n            }\n            else if (this.autocomplete) {\n                var prevActiveItem = this.autocomplete._keyManager.activeItem;\n                var isArrowKey = keyCode === keycodes.UP_ARROW || keyCode === keycodes.DOWN_ARROW;\n                if (this.panelOpen || keyCode === keycodes.TAB) {\n                    this.autocomplete._keyManager.onKeydown(event);\n                }\n                else if (isArrowKey && this._canOpen()) {\n                    this.openPanel();\n                }\n                if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\n                    this._scrollToOption();\n                }\n            }\n        };\n        MatAutocompleteTrigger.prototype._handleInput = function (event) {\n            var target = event.target;\n            var value = target.value;\n            // Based on `NumberValueAccessor` from forms.\n            if (target.type === 'number') {\n                value = value == '' ? null : parseFloat(value);\n            }\n            // If the input has a placeholder, IE will fire the `input` event on page load,\n            // focus and blur, in addition to when the user actually changed the value. To\n            // filter out all of the extra events, we save the value on focus and between\n            // `input` events, and we check whether it changed.\n            // See: https://connect.microsoft.com/IE/feedback/details/885747/\n            if (this._previousValue !== value) {\n                this._previousValue = value;\n                this._onChange(value);\n                if (this._canOpen() && this._document.activeElement === event.target) {\n                    this.openPanel();\n                }\n            }\n        };\n        MatAutocompleteTrigger.prototype._handleFocus = function () {\n            if (!this._canOpenOnNextFocus) {\n                this._canOpenOnNextFocus = true;\n            }\n            else if (this._canOpen()) {\n                this._previousValue = this._element.nativeElement.value;\n                this._attachOverlay();\n                this._floatLabel(true);\n            }\n        };\n        /**\n         * In \"auto\" mode, the label will animate down as soon as focus is lost.\n         * This causes the value to jump when selecting an option with the mouse.\n         * This method manually floats the label until the panel can be closed.\n         * @param shouldAnimate Whether the label should be animated when it is floated.\n         */\n        MatAutocompleteTrigger.prototype._floatLabel = function (shouldAnimate) {\n            if (shouldAnimate === void 0) { shouldAnimate = false; }\n            if (this._formField && this._formField.floatLabel === 'auto') {\n                if (shouldAnimate) {\n                    this._formField._animateAndLockLabel();\n                }\n                else {\n                    this._formField.floatLabel = 'always';\n                }\n                this._manuallyFloatingLabel = true;\n            }\n        };\n        /** If the label has been manually elevated, return it to its normal state. */\n        MatAutocompleteTrigger.prototype._resetLabel = function () {\n            if (this._manuallyFloatingLabel) {\n                this._formField.floatLabel = 'auto';\n                this._manuallyFloatingLabel = false;\n            }\n        };\n        /**\n         * Given that we are not actually focusing active options, we must manually adjust scroll\n         * to reveal options below the fold. First, we find the offset of the option from the top\n         * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n         * the panel height + the option height, so the active option will be just visible at the\n         * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n         * will become the offset. If that offset is visible within the panel already, the scrollTop is\n         * not adjusted.\n         */\n        MatAutocompleteTrigger.prototype._scrollToOption = function () {\n            var index = this.autocomplete._keyManager.activeItemIndex || 0;\n            var labelCount = core$1._countGroupLabelsBeforeOption(index, this.autocomplete.options, this.autocomplete.optionGroups);\n            if (index === 0 && labelCount === 1) {\n                // If we've got one group label before the option and we're at the top option,\n                // scroll the list to the top. This is better UX than scrolling the list to the\n                // top of the option, because it allows the user to read the top group's label.\n                this.autocomplete._setScrollTop(0);\n            }\n            else {\n                var newScrollPosition = core$1._getOptionScrollPosition(index + labelCount, AUTOCOMPLETE_OPTION_HEIGHT, this.autocomplete._getScrollTop(), AUTOCOMPLETE_PANEL_HEIGHT);\n                this.autocomplete._setScrollTop(newScrollPosition);\n            }\n        };\n        /**\n         * This method listens to a stream of panel closing actions and resets the\n         * stream every time the option list changes.\n         */\n        MatAutocompleteTrigger.prototype._subscribeToClosingActions = function () {\n            var _this = this;\n            var firstStable = this._zone.onStable.asObservable().pipe(operators.take(1));\n            var optionChanges = this.autocomplete.options.changes.pipe(operators.tap(function () { return _this._positionStrategy.reapplyLastPosition(); }), \n            // Defer emitting to the stream until the next tick, because changing\n            // bindings in here will cause \"changed after checked\" errors.\n            operators.delay(0));\n            // When the zone is stable initially, and when the option list changes...\n            return rxjs.merge(firstStable, optionChanges)\n                .pipe(\n            // create a new stream of panelClosingActions, replacing any previous streams\n            // that were created, and flatten it so our stream only emits closing events...\n            operators.switchMap(function () {\n                var wasOpen = _this.panelOpen;\n                _this._resetActiveItem();\n                _this.autocomplete._setVisibility();\n                if (_this.panelOpen) {\n                    _this._overlayRef.updatePosition();\n                    // If the `panelOpen` state changed, we need to make sure to emit the `opened`\n                    // event, because we may not have emitted it when the panel was attached. This\n                    // can happen if the users opens the panel and there are no options, but the\n                    // options come in slightly later or as a result of the value changing.\n                    if (wasOpen !== _this.panelOpen) {\n                        _this.autocomplete.opened.emit();\n                    }\n                }\n                return _this.panelClosingActions;\n            }), \n            // when the first closing event occurs...\n            operators.take(1))\n                // set the value, close the panel, and complete.\n                .subscribe(function (event) { return _this._setValueAndClose(event); });\n        };\n        /** Destroys the autocomplete suggestion panel. */\n        MatAutocompleteTrigger.prototype._destroyPanel = function () {\n            if (this._overlayRef) {\n                this.closePanel();\n                this._overlayRef.dispose();\n                this._overlayRef = null;\n            }\n        };\n        MatAutocompleteTrigger.prototype._setTriggerValue = function (value) {\n            var toDisplay = this.autocomplete && this.autocomplete.displayWith ?\n                this.autocomplete.displayWith(value) :\n                value;\n            // Simply falling back to an empty string if the display value is falsy does not work properly.\n            // The display value can also be the number zero and shouldn't fall back to an empty string.\n            var inputValue = toDisplay != null ? toDisplay : '';\n            // If it's used within a `MatFormField`, we should set it through the property so it can go\n            // through change detection.\n            if (this._formField) {\n                this._formField._control.value = inputValue;\n            }\n            else {\n                this._element.nativeElement.value = inputValue;\n            }\n            this._previousValue = inputValue;\n        };\n        /**\n         * This method closes the panel, and if a value is specified, also sets the associated\n         * control to that value. It will also mark the control as dirty if this interaction\n         * stemmed from the user.\n         */\n        MatAutocompleteTrigger.prototype._setValueAndClose = function (event) {\n            if (event && event.source) {\n                this._clearPreviousSelectedOption(event.source);\n                this._setTriggerValue(event.source.value);\n                this._onChange(event.source.value);\n                this._element.nativeElement.focus();\n                this.autocomplete._emitSelectEvent(event.source);\n            }\n            this.closePanel();\n        };\n        /**\n         * Clear any previous selected option and emit a selection change event for this option\n         */\n        MatAutocompleteTrigger.prototype._clearPreviousSelectedOption = function (skip) {\n            this.autocomplete.options.forEach(function (option) {\n                if (option != skip && option.selected) {\n                    option.deselect();\n                }\n            });\n        };\n        MatAutocompleteTrigger.prototype._attachOverlay = function () {\n            var _this = this;\n            if (!this.autocomplete) {\n                throw getMatAutocompleteMissingPanelError();\n            }\n            var overlayRef = this._overlayRef;\n            if (!overlayRef) {\n                this._portal = new portal.TemplatePortal(this.autocomplete.template, this._viewContainerRef);\n                overlayRef = this._overlay.create(this._getOverlayConfig());\n                this._overlayRef = overlayRef;\n                // Use the `keydownEvents` in order to take advantage of\n                // the overlay event targeting provided by the CDK overlay.\n                overlayRef.keydownEvents().subscribe(function (event) {\n                    // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n                    // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n                    if (event.keyCode === keycodes.ESCAPE || (event.keyCode === keycodes.UP_ARROW && event.altKey)) {\n                        _this._resetActiveItem();\n                        _this._closeKeyEventStream.next();\n                        // We need to stop propagation, otherwise the event will eventually\n                        // reach the input itself and cause the overlay to be reopened.\n                        event.stopPropagation();\n                        event.preventDefault();\n                    }\n                });\n                if (this._viewportRuler) {\n                    this._viewportSubscription = this._viewportRuler.change().subscribe(function () {\n                        if (_this.panelOpen && overlayRef) {\n                            overlayRef.updateSize({ width: _this._getPanelWidth() });\n                        }\n                    });\n                }\n            }\n            else {\n                // Update the trigger, panel width and direction, in case anything has changed.\n                this._positionStrategy.setOrigin(this._getConnectedElement());\n                overlayRef.updateSize({ width: this._getPanelWidth() });\n            }\n            if (overlayRef && !overlayRef.hasAttached()) {\n                overlayRef.attach(this._portal);\n                this._closingActionsSubscription = this._subscribeToClosingActions();\n            }\n            var wasOpen = this.panelOpen;\n            this.autocomplete._setVisibility();\n            this.autocomplete._isOpen = this._overlayAttached = true;\n            // We need to do an extra `panelOpen` check in here, because the\n            // autocomplete won't be shown if there are no options.\n            if (this.panelOpen && wasOpen !== this.panelOpen) {\n                this.autocomplete.opened.emit();\n            }\n        };\n        MatAutocompleteTrigger.prototype._getOverlayConfig = function () {\n            return new overlay.OverlayConfig({\n                positionStrategy: this._getOverlayPosition(),\n                scrollStrategy: this._scrollStrategy(),\n                width: this._getPanelWidth(),\n                direction: this._dir\n            });\n        };\n        MatAutocompleteTrigger.prototype._getOverlayPosition = function () {\n            var strategy = this._overlay.position()\n                .flexibleConnectedTo(this._getConnectedElement())\n                .withFlexibleDimensions(false)\n                .withPush(false);\n            this._setStrategyPositions(strategy);\n            this._positionStrategy = strategy;\n            return strategy;\n        };\n        /** Sets the positions on a position strategy based on the directive's input state. */\n        MatAutocompleteTrigger.prototype._setStrategyPositions = function (positionStrategy) {\n            var belowPosition = {\n                originX: 'start',\n                originY: 'bottom',\n                overlayX: 'start',\n                overlayY: 'top'\n            };\n            var abovePosition = {\n                originX: 'start',\n                originY: 'top',\n                overlayX: 'start',\n                overlayY: 'bottom',\n                // The overlay edge connected to the trigger should have squared corners, while\n                // the opposite end has rounded corners. We apply a CSS class to swap the\n                // border-radius based on the overlay position.\n                panelClass: 'mat-autocomplete-panel-above'\n            };\n            var positions;\n            if (this.position === 'above') {\n                positions = [abovePosition];\n            }\n            else if (this.position === 'below') {\n                positions = [belowPosition];\n            }\n            else {\n                positions = [belowPosition, abovePosition];\n            }\n            positionStrategy.withPositions(positions);\n        };\n        MatAutocompleteTrigger.prototype._getConnectedElement = function () {\n            if (this.connectedTo) {\n                return this.connectedTo.elementRef;\n            }\n            return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;\n        };\n        MatAutocompleteTrigger.prototype._getPanelWidth = function () {\n            return this.autocomplete.panelWidth || this._getHostWidth();\n        };\n        /** Returns the width of the input element, so the panel width can match it. */\n        MatAutocompleteTrigger.prototype._getHostWidth = function () {\n            return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\n        };\n        /**\n         * Resets the active item to -1 so arrow events will activate the\n         * correct options, or to 0 if the consumer opted into it.\n         */\n        MatAutocompleteTrigger.prototype._resetActiveItem = function () {\n            this.autocomplete._keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption ? 0 : -1);\n        };\n        /** Determines whether the panel can be opened. */\n        MatAutocompleteTrigger.prototype._canOpen = function () {\n            var element = this._element.nativeElement;\n            return !element.readOnly && !element.disabled && !this._autocompleteDisabled;\n        };\n        MatAutocompleteTrigger.decorators = [\n            { type: core.Directive, args: [{\n                        selector: \"input[matAutocomplete], textarea[matAutocomplete]\",\n                        host: {\n                            'class': 'mat-autocomplete-trigger',\n                            '[attr.autocomplete]': 'autocompleteAttribute',\n                            '[attr.role]': 'autocompleteDisabled ? null : \"combobox\"',\n                            '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : \"list\"',\n                            '[attr.aria-activedescendant]': '(panelOpen && activeOption) ? activeOption.id : null',\n                            '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',\n                            '[attr.aria-owns]': '(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id',\n                            '[attr.aria-haspopup]': '!autocompleteDisabled',\n                            // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\n                            // a little earlier. This avoids issues where IE delays the focusing of the input.\n                            '(focusin)': '_handleFocus()',\n                            '(blur)': '_onTouched()',\n                            '(input)': '_handleInput($event)',\n                            '(keydown)': '_handleKeydown($event)',\n                        },\n                        exportAs: 'matAutocompleteTrigger',\n                        providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR]\n                    },] }\n        ];\n        /** @nocollapse */\n        MatAutocompleteTrigger.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: overlay.Overlay },\n            { type: core.ViewContainerRef },\n            { type: core.NgZone },\n            { type: core.ChangeDetectorRef },\n            { type: undefined, decorators: [{ type: core.Inject, args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY,] }] },\n            { type: bidi.Directionality, decorators: [{ type: core.Optional }] },\n            { type: formField.MatFormField, decorators: [{ type: core.Optional }, { type: core.Host }] },\n            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] },\n            { type: scrolling.ViewportRuler }\n        ]; };\n        MatAutocompleteTrigger.propDecorators = {\n            autocomplete: [{ type: core.Input, args: ['matAutocomplete',] }],\n            position: [{ type: core.Input, args: ['matAutocompletePosition',] }],\n            connectedTo: [{ type: core.Input, args: ['matAutocompleteConnectedTo',] }],\n            autocompleteAttribute: [{ type: core.Input, args: ['autocomplete',] }],\n            autocompleteDisabled: [{ type: core.Input, args: ['matAutocompleteDisabled',] }]\n        };\n        return MatAutocompleteTrigger;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var MatAutocompleteModule = /** @class */ (function () {\n        function MatAutocompleteModule() {\n        }\n        MatAutocompleteModule.decorators = [\n            { type: core.NgModule, args: [{\n                        imports: [core$1.MatOptionModule, overlay.OverlayModule, core$1.MatCommonModule, common.CommonModule],\n                        exports: [\n                            MatAutocomplete,\n                            core$1.MatOptionModule,\n                            MatAutocompleteTrigger,\n                            MatAutocompleteOrigin,\n                            core$1.MatCommonModule\n                        ],\n                        declarations: [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin],\n                        providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],\n                    },] }\n        ];\n        return MatAutocompleteModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.MatAutocompleteSelectedEvent = MatAutocompleteSelectedEvent;\n    exports.MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = MAT_AUTOCOMPLETE_DEFAULT_OPTIONS;\n    exports.MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY = MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY;\n    exports.MatAutocomplete = MatAutocomplete;\n    exports.MatAutocompleteModule = MatAutocompleteModule;\n    exports.AUTOCOMPLETE_OPTION_HEIGHT = AUTOCOMPLETE_OPTION_HEIGHT;\n    exports.AUTOCOMPLETE_PANEL_HEIGHT = AUTOCOMPLETE_PANEL_HEIGHT;\n    exports.MAT_AUTOCOMPLETE_SCROLL_STRATEGY = MAT_AUTOCOMPLETE_SCROLL_STRATEGY;\n    exports.MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY = MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY;\n    exports.MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER;\n    exports.MAT_AUTOCOMPLETE_VALUE_ACCESSOR = MAT_AUTOCOMPLETE_VALUE_ACCESSOR;\n    exports.getMatAutocompleteMissingPanelError = getMatAutocompleteMissingPanelError;\n    exports.MatAutocompleteTrigger = MatAutocompleteTrigger;\n    exports.MatAutocompleteOrigin = MatAutocompleteOrigin;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=material-autocomplete.umd.js.map\n"]}